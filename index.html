<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>SICP</title>

<meta name="description" content="SICP">
<meta name="keywords" content="SICP">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#Main-Index" rel="index" title="Main Index">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="css/style.css">


<link rel="stylesheet" href="css/github.css">
<script src="js/highlight.pack.js"></script>
<script>document.addEventListener("DOMContentLoaded", (event) => {document.querySelectorAll("div pre").forEach((block) => {hljs.highlightBlock(block);});}); </script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body lang="en">
<h1 class="settitle" align="center">SICP</h1>


<span id="SEC_Contents"></span>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a id="toc-Building-Abstractions-with-Procedures-1" href="#Building-Abstractions-with-Procedures">1 Building Abstractions with Procedures</a>
  <ul class="no-bullet">
    <li><a id="toc-Elements-of-Programming-1" href="#Elements-of-Programming">1.1 Elements of Programming</a>
    <ul class="no-bullet">
      <li><a id="toc-Expressions-1" href="#Expressions">1.1.1 Expressions</a></li>
      <li><a id="toc-Naming-and-the-Environment-1" href="#Naming-and-the-Environment">1.1.2 Naming and the Environment</a></li>
      <li><a id="toc-Evaluating-Combinations-1" href="#Evaluating-Combinations">1.1.3 Evaluating Combinations</a></li>
      <li><a id="toc-Compound-Procedures-1" href="#Compound-Procedures">1.1.4 Compound Procedures</a></li>
      <li><a id="toc-The-Substitution-Model-for-Procedure-Application-1" href="#The-Substitution-Model-for-Procedure-Application">1.1.5 The Substitution Model for Procedure Application</a></li>
      <li><a id="toc-Conditional-Expressions-and-Predicates-1" href="#Conditional-Expressions-and-Predicates">1.1.6 Conditional Expressions and Predicates</a></li>
      <li><a id="toc-Example-Square-Roots-by-Newton_0027s-Method-1" href="#Example-Square-Roots-by-Newton_0027s-Method">1.1.7 Example Square Roots by Newton&rsquo;s Method</a></li>
      <li><a id="toc-Procedures-as-Black_002dBox-Abstractions-1" href="#Procedures-as-Black_002dBox-Abstractions">1.1.8 Procedures as Black-Box Abstractions</a></li>
    </ul></li>
    <li><a id="toc-Procedures-and-the-Processes-They-Generate-1" href="#Procedures-and-the-Processes-They-Generate">1.2 Procedures and the Processes They Generate</a>
    <ul class="no-bullet">
      <li><a id="toc-Linear-Recursion-and-Iteration-1" href="#Linear-Recursion-and-Iteration">1.2.1 Linear Recursion and Iteration</a></li>
      <li><a id="toc-Tree-Recursion-1" href="#Tree-Recursion">1.2.2 Tree Recursion</a></li>
      <li><a id="toc-Orders-of-Growth-1" href="#Orders-of-Growth">1.2.3 Orders of Growth</a></li>
      <li><a id="toc-Exponentiation-1" href="#Exponentiation">1.2.4 Exponentiation</a></li>
      <li><a id="toc-Greatest-Common-Divisors-1" href="#Greatest-Common-Divisors">1.2.5 Greatest Common Divisors</a></li>
      <li><a id="toc-Example-Testing-for-Primality-1" href="#Example-Testing-for-Primality">1.2.6 Example Testing for Primality</a></li>
    </ul></li>
    <li><a id="toc-Formulating-Abstractions-with-Higher_002dOrder-Procedures-1" href="#Formulating-Abstractions-with-Higher_002dOrder-Procedures">1.3 Formulating Abstractions with Higher-Order Procedures</a>
    <ul class="no-bullet">
      <li><a id="toc-Procedures-as-Arguments-1" href="#Procedures-as-Arguments">1.3.1 Procedures as Arguments</a></li>
      <li><a id="toc-Constructing-Procedures-Using-Lambda-1" href="#Constructing-Procedures-Using-Lambda">1.3.2 Constructing Procedures Using Lambda</a></li>
      <li><a id="toc-Procedures-as-General-Methods-1" href="#Procedures-as-General-Methods">1.3.3 Procedures as General Methods</a></li>
      <li><a id="toc-Procedures-as-Returned-Values-1" href="#Procedures-as-Returned-Values">1.3.4 Procedures as Returned Values</a></li>
    </ul></li>
  </ul></li>
  <li><a id="toc-Building-Abstractions-with-Data-1" href="#Building-Abstractions-with-Data">2 Building Abstractions with Data</a>
  <ul class="no-bullet">
    <li><a id="toc-Introduction-to-Data-Abstraction-1" href="#Introduction-to-Data-Abstraction">2.1 Introduction to Data Abstraction</a>
    <ul class="no-bullet">
      <li><a id="toc-Example-Arithmetic-Operations-for-Rational-Numbers-1" href="#Example-Arithmetic-Operations-for-Rational-Numbers">2.1.1 Example Arithmetic Operations for Rational Numbers</a></li>
      <li><a id="toc-Abstraction-Barriers-1" href="#Abstraction-Barriers">2.1.2 Abstraction Barriers</a></li>
      <li><a id="toc-What-Is-Meant-by-Data_003f-1" href="#What-Is-Meant-by-Data_003f">2.1.3 What Is Meant by Data?</a></li>
      <li><a id="toc-Extended-Exercise-Interval-Arithmetic-1" href="#Extended-Exercise-Interval-Arithmetic">2.1.4 Extended Exercise Interval Arithmetic</a></li>
    </ul></li>
    <li><a id="toc-Hierarchical-Data-and-the-Closure-Property-1" href="#Hierarchical-Data-and-the-Closure-Property">2.2 Hierarchical Data and the Closure Property</a>
    <ul class="no-bullet">
      <li><a id="toc-Representing-Sequences-1" href="#Representing-Sequences">2.2.1 Representing Sequences</a></li>
      <li><a id="toc-Hierarchical-Structures-1" href="#Hierarchical-Structures">2.2.2 Hierarchical Structures</a></li>
      <li><a id="toc-Sequences-as-Conventional-Interfaces-1" href="#Sequences-as-Conventional-Interfaces">2.2.3 Sequences as Conventional Interfaces</a></li>
      <li><a id="toc-Example-A-Picture-Language-1" href="#Example-A-Picture-Language">2.2.4 Example A Picture Language</a></li>
    </ul></li>
  </ul></li>
  <li><a id="toc-Computing-with-Register-Machines-1" href="#Computing-with-Register-Machines">3 Computing with Register Machines</a>
  <ul class="no-bullet">
    <li><a id="toc-Designing-Register-Machines-1" href="#Designing-Register-Machines">3.1 Designing Register Machines</a>
    <ul class="no-bullet">
      <li><a id="toc-A-Language-for-Describing-Register-Machines-1" href="#A-Language-for-Describing-Register-Machines">3.1.1 A Language for Describing Register Machines</a></li>
      <li><a id="toc-Actions-1" href="#Actions">3.1.2 Actions</a></li>
      <li><a id="toc-Abstraction-in-Machine-Design-1" href="#Abstraction-in-Machine-Design">3.1.3 Abstraction in Machine Design</a></li>
      <li><a id="toc-Subroutines-1" href="#Subroutines">3.1.4 Subroutines</a></li>
      <li><a id="toc-Using-a-Stack-to-Implement-Recursion-1" href="#Using-a-Stack-to-Implement-Recursion">3.1.5 Using a Stack to Implement Recursion</a></li>
      <li><a id="toc-Instruction-Summary-1" href="#Instruction-Summary">3.1.6 Instruction Summary</a></li>
    </ul></li>
    <li><a id="toc-A-Register_002dMachine-Simulator-1" href="#A-Register_002dMachine-Simulator">3.2 A Register-Machine Simulator</a>
    <ul class="no-bullet">
      <li><a id="toc-The-Machine-Model-1" href="#The-Machine-Model">3.2.1 The Machine Model</a></li>
      <li><a id="toc-The-Assembler-1" href="#The-Assembler">3.2.2 The Assembler</a></li>
      <li><a id="toc-Generating-Execution-Procedures-for-Instructions-1" href="#Generating-Execution-Procedures-for-Instructions">3.2.3 Generating Execution Procedures for Instructions</a></li>
      <li><a id="toc-Monitoring-Machine-Performance-1" href="#Monitoring-Machine-Performance">3.2.4 Monitoring Machine Performance</a></li>
    </ul></li>
  </ul></li>
  <li><a id="toc-Foreward-1" href="#Foreward">Appendix A Foreward</a></li>
  <li><a id="toc-Common-code-1" href="#Common-code">Appendix B Common code</a></li>
  <li><a id="toc-Main-Index-1" href="#Main-Index" rel="index">C Main Index</a></li>
  <li><a id="toc-Procedure-Index-1" href="#Procedure-Index" rel="index">D Procedure Index</a></li>
  <li><a id="toc-Exercise-Index-1" href="#Exercise-Index" rel="index">E Exercise Index</a></li>
</ul>
</div>


<span id="Top"></span><div class="header">
<p>
Next: <a href="#Building-Abstractions-with-Procedures" accesskey="n" rel="next">Building Abstractions with Procedures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="SICP"></span><h1 class="top">SICP</h1>

<p>This article was written using Emacs in Org mode, then exported to Texinfo format, and finally to HTML.
</p>
<p>Here are some useful links:
</p>
<ul>
<li> <a href="https://shichaoxia.github.io/sicp-2e/">Structure and Interpretation of Computer Programs 2nd edition</a>
</li><li> <a href="http://community.schemewiki.org/?SICP-Solutions">SICP-Solutions</a>
</li><li> <a href="https://mitpress.mit.edu/sites/default/files/sicp/code/index.html">Complete Code from SICP Second Edition</a>
</li><li> <a href="http://www.composingprograms.com">Composing Programs</a>
</li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Building-Abstractions-with-Procedures" accesskey="1">Building Abstractions with Procedures</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Building-Abstractions-with-Data" accesskey="2">Building Abstractions with Data</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Computing-with-Register-Machines" accesskey="3">Computing with Register Machines</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Foreward" accesskey="4">Foreward</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Common-code" accesskey="5">Common code</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Main-Index" rel="index" accesskey="6">Main Index</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Procedure-Index" rel="index" accesskey="7">Procedure Index</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Exercise-Index" rel="index" accesskey="8">Exercise Index</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr><tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">&mdash; The Detailed Node Listing &mdash;

Building Abstractions with Procedures

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Elements-of-Programming" accesskey="9">Elements of Programming</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Procedures-and-the-Processes-They-Generate">Procedures and the Processes They Generate</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Formulating-Abstractions-with-Higher_002dOrder-Procedures">Formulating Abstractions with Higher-Order Procedures</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Elements of Programming

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Expressions">Expressions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Naming-and-the-Environment">Naming and the Environment</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Evaluating-Combinations">Evaluating Combinations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Compound-Procedures">Compound Procedures</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-Substitution-Model-for-Procedure-Application">The Substitution Model for Procedure Application</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Conditional-Expressions-and-Predicates">Conditional Expressions and Predicates</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Example-Square-Roots-by-Newton_0027s-Method">Example Square Roots by Newton's Method</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Procedures-as-Black_002dBox-Abstractions">Procedures as Black-Box Abstractions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Procedures and the Processes They Generate

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Linear-Recursion-and-Iteration">Linear Recursion and Iteration</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tree-Recursion">Tree Recursion</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Orders-of-Growth">Orders of Growth</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Exponentiation">Exponentiation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Greatest-Common-Divisors">Greatest Common Divisors</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Example-Testing-for-Primality">Example Testing for Primality</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Formulating Abstractions with Higher-Order Procedures

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Procedures-as-Arguments">Procedures as Arguments</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Constructing-Procedures-Using-Lambda">Constructing Procedures Using Lambda</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Procedures-as-General-Methods">Procedures as General Methods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Procedures-as-Returned-Values">Procedures as Returned Values</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Building Abstractions with Data

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Introduction-to-Data-Abstraction">Introduction to Data Abstraction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Hierarchical-Data-and-the-Closure-Property">Hierarchical Data and the Closure Property</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Introduction to Data Abstraction

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Example-Arithmetic-Operations-for-Rational-Numbers">Example Arithmetic Operations for Rational Numbers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Abstraction-Barriers">Abstraction Barriers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#What-Is-Meant-by-Data_003f">What Is Meant by Data?</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Extended-Exercise-Interval-Arithmetic">Extended Exercise Interval Arithmetic</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Hierarchical Data and the Closure Property

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Representing-Sequences">Representing Sequences</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Hierarchical-Structures">Hierarchical Structures</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Example-A-Picture-Language">Example A Picture Language</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Computing with Register Machines

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Designing-Register-Machines">Designing Register Machines</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#A-Register_002dMachine-Simulator">A Register-Machine Simulator</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Designing Register Machines

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#A-Language-for-Describing-Register-Machines">A Language for Describing Register Machines</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Actions">Actions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Abstraction-in-Machine-Design">Abstraction in Machine Design</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Subroutines">Subroutines</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-a-Stack-to-Implement-Recursion">Using a Stack to Implement Recursion</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Instruction-Summary">Instruction Summary</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

A Register-Machine Simulator

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#The-Machine-Model">The Machine Model</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-Assembler">The Assembler</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Generating-Execution-Procedures-for-Instructions">Generating Execution Procedures for Instructions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Monitoring-Machine-Performance">Monitoring Machine Performance</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr></table>

<hr>
<span id="Building-Abstractions-with-Procedures"></span><div class="header">
<p>
Next: <a href="#Building-Abstractions-with-Data" accesskey="n" rel="next">Building Abstractions with Data</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Building-Abstractions-with-Procedures-1"></span><h2 class="chapter">1 Building Abstractions with Procedures</h2>

<span id="index-interpreter"></span>
<span id="index-computational-process"></span>
<span id="index-data"></span>
<span id="index-program"></span>

<ul>
<li> What is the relationship between <em>computational process</em>, <em>data</em> and <em>program</em>?

<p>Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract things called data. The evolution of a process is directed by a pattern of rules called a program. People create programs to direct processes.
</p>
</li><li> What is Lisp interpreter?

<p>A Lisp interpreter is a machine that carries out processes described in the Lisp language.
</p>
</li><li> If Lisp is not a mainstream language, why are we using it as the framework for our discussion of programming?

<p>Because the language possesses unique features that make it an excellent medium for studying important programming constructs and data structures and for relating them to the linguistic features that support them. The most significant of these features is the fact that Lisp descriptions of processes, called procedures, can themselves be represented and manipulated as Lisp data.
</p></li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Elements-of-Programming" accesskey="1">Elements of Programming</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Procedures-and-the-Processes-They-Generate" accesskey="2">Procedures and the Processes They Generate</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Formulating-Abstractions-with-Higher_002dOrder-Procedures" accesskey="3">Formulating Abstractions with Higher-Order Procedures</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Elements-of-Programming"></span><div class="header">
<p>
Next: <a href="#Procedures-and-the-Processes-They-Generate" accesskey="n" rel="next">Procedures and the Processes They Generate</a>, Up: <a href="#Building-Abstractions-with-Procedures" accesskey="u" rel="up">Building Abstractions with Procedures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Elements-of-Programming-1"></span><h3 class="section">1.1 Elements of Programming</h3>

<ul>
<li> What mechanisms does a powerful language have for combining simple ideas to form more complex ideas?
<ul>
<li> primitive expressions, which represent the simplest entities the language is concerned with, e.g. <code>123</code>.
</li><li> means of combination, by which compound elements are built from simpler ones, e.g. <code>(+ 1 23)</code>.
</li><li> means of abstraction, by which compound elements can be named and manipulated as units.
</li></ul>
</li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Expressions" accesskey="1">Expressions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Naming-and-the-Environment" accesskey="2">Naming and the Environment</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Evaluating-Combinations" accesskey="3">Evaluating Combinations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Compound-Procedures" accesskey="4">Compound Procedures</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-Substitution-Model-for-Procedure-Application" accesskey="5">The Substitution Model for Procedure Application</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Conditional-Expressions-and-Predicates" accesskey="6">Conditional Expressions and Predicates</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Example-Square-Roots-by-Newton_0027s-Method" accesskey="7">Example Square Roots by Newton's Method</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Procedures-as-Black_002dBox-Abstractions" accesskey="8">Procedures as Black-Box Abstractions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Expressions"></span><div class="header">
<p>
Next: <a href="#Naming-and-the-Environment" accesskey="n" rel="next">Naming and the Environment</a>, Up: <a href="#Elements-of-Programming" accesskey="u" rel="up">Elements of Programming</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Expressions-1"></span><h4 class="subsection">1.1.1 Expressions</h4>

<span id="index-combination"></span>
<span id="index-prefix-notation"></span>

<dl compact="compact">
<dt>combinations</dt>
<dd><p>Expressions formed by delimiting a list of expressions within parentheses in order to denote procedure application. The leftmost element in the list is called the <code>operator</code>, and the other elements are called <code>operands</code>. The value of a combination is obtained by applying the procedure specified by the operator to the <code>arguments</code> that are the values of the operands.
</p>
</dd>
<dt>prefix notation</dt>
<dd><p>The convention of placing the operator to the left of the operands.
</p></dd>
</dl>

<hr>
<span id="Naming-and-the-Environment"></span><div class="header">
<p>
Next: <a href="#Evaluating-Combinations" accesskey="n" rel="next">Evaluating Combinations</a>, Previous: <a href="#Expressions" accesskey="p" rel="prev">Expressions</a>, Up: <a href="#Elements-of-Programming" accesskey="u" rel="up">Elements of Programming</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Naming-and-the-Environment-1"></span><h4 class="subsection">1.1.2 Naming and the Environment</h4>

<span id="index-environment"></span>

<ul>
<li> What is our language’s simplest means of abstraction?

<p>Using names to refer to computational objects
</p>
</li><li> environment
Interpreter must maintain some sort of memory that keeps track of the name-object pairs. This memory is called the environment.
</li></ul>

<hr>
<span id="Evaluating-Combinations"></span><div class="header">
<p>
Next: <a href="#Compound-Procedures" accesskey="n" rel="next">Compound Procedures</a>, Previous: <a href="#Naming-and-the-Environment" accesskey="p" rel="prev">Naming and the Environment</a>, Up: <a href="#Elements-of-Programming" accesskey="u" rel="up">Elements of Programming</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Evaluating-Combinations-1"></span><h4 class="subsection">1.1.3 Evaluating Combinations</h4>

<span id="index-evaluate-a-combination"></span>
<span id="index-special-form"></span>

<ul>
<li> How to evaluate a combination?

<ol>
<li> Evaluate the subexpressions of the combination.
</li><li> Apply the procedure that is the value of the leftmost subexpression (the operator) to the arguments that are the values of the other subexpressions (the operands).
</li></ol>

</li><li> special forms
Evaluating (define x 3) does not apply define to two arguments, since the purpose of the define is precisely to associate x with a value. (That is, (define x 3) is not a combination.) Such exceptions to the general evaluation rule are called special forms. Each special form has its own evaluation rule. The various kinds of expressions (each with its associated evaluation rule) constitute the syntax of the programming language.
</li></ul>

<hr>
<span id="Compound-Procedures"></span><div class="header">
<p>
Next: <a href="#The-Substitution-Model-for-Procedure-Application" accesskey="n" rel="next">The Substitution Model for Procedure Application</a>, Previous: <a href="#Evaluating-Combinations" accesskey="p" rel="prev">Evaluating Combinations</a>, Up: <a href="#Elements-of-Programming" accesskey="u" rel="up">Elements of Programming</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Compound-Procedures-1"></span><h4 class="subsection">1.1.4 Compound Procedures</h4>

<span id="index-procedure"></span>

<dl compact="compact">
<dt>procedure definitions</dt>
<dd><p>A much more powerful abstraction technique by which a compound operation can be given a name and then referred to as a unit.
</p></dd>
</dl>

<hr>
<span id="The-Substitution-Model-for-Procedure-Application"></span><div class="header">
<p>
Next: <a href="#Conditional-Expressions-and-Predicates" accesskey="n" rel="next">Conditional Expressions and Predicates</a>, Previous: <a href="#Compound-Procedures" accesskey="p" rel="prev">Compound Procedures</a>, Up: <a href="#Elements-of-Programming" accesskey="u" rel="up">Elements of Programming</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-Substitution-Model-for-Procedure-Application-1"></span><h4 class="subsection">1.1.5 The Substitution Model for Procedure Application</h4>

<span id="index-applicative-order_002c-normal-order"></span>

<dl compact="compact">
<dt>applicative order</dt>
<dd><p>First evaluates the operator and operands and then applies the resulting procedure to the resulting arguments.
</p>
</dd>
<dt>normal order</dt>
<dd><p>Would not evaluate the operands until their values were needed. Instead it would first substitute operand expressions for parameters until it obtained an expression involving only primitive operators, and would then perform the evaluation.
</p></dd>
</dl>

<hr>
<span id="Conditional-Expressions-and-Predicates"></span><div class="header">
<p>
Next: <a href="#Example-Square-Roots-by-Newton_0027s-Method" accesskey="n" rel="next">Example Square Roots by Newton's Method</a>, Previous: <a href="#The-Substitution-Model-for-Procedure-Application" accesskey="p" rel="prev">The Substitution Model for Procedure Application</a>, Up: <a href="#Elements-of-Programming" accesskey="u" rel="up">Elements of Programming</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Conditional-Expressions-and-Predicates-1"></span><h4 class="subsection">1.1.6 Conditional Expressions and Predicates</h4>

<ul>
<li> What&rsquo;s the difference between if and cond?

<p>The ⟨e⟩ part of each cond clause may be a sequence of expressions. If the corresponding ⟨p⟩ is found to be true, the expressions ⟨e⟩ are evaluated in sequence and the value of the final expression in the sequence is returned as the value of the cond. In an if expression, however, the ⟨consequent⟩ and ⟨alternative⟩ must be single expressions.
</p></li></ul>

<ol>
<li> Exercise 1.1


<span id="index-1_002e01"></span>
<p>Below is a sequence of expressions. What is the result printed by the interpreter in response to each expression? Assume that the sequence is to be evaluated in the order in which it is presented.
</p>
<div class="example">
<pre class="example">10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
(= a b)
(if (and (&gt; b a) (&lt; b (* a b)))
    b
    a)
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
(+ 2 (if (&gt; b a) b a))
(* (cond ((&gt; a b) a)
         ((&lt; a b) b)
         (else -1))
   (+ a 1))
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">1 ]=&gt; 10
;Value: 10

1 ]=&gt; (+ 5 3 4)
;Value: 12

1 ]=&gt; (- 9 1)
;Value: 8

1 ]=&gt; (/ 6 2)
;Value: 3

1 ]=&gt; (+ (* 2 4) (- 4 6))
;Value: 6

1 ]=&gt; (define a 3)
;Value: a

1 ]=&gt; (define b (+ a 1))
;Value: b

1 ]=&gt; (+ a b (* a b))
;Value: 19

1 ]=&gt; (= a b)
;Value: #f

1 ]=&gt; (if (and (&gt; b a) (&lt; b (* a b)))
b
a)
;Value: 4

1 ]=&gt; (cond ((= a 4) 6)
((= b 4) (+ 6 7 a))
(else 25))
;Value: 16

1 ]=&gt; (+ 2 (if (&gt; b a) b a))
;Value: 6

1 ]=&gt; (* (cond ((&gt; a b) a)
((&lt; a b) b)
(else -1))
(+ a 1))
;Value: 16
</pre></div>

</li><li> Exercise 1.2


<span id="index-1_002e02"></span>
<p>Translate the following expression into prefix form:
</p>
<p>\begin{equation*}
       \frac{5+4+(2-(3-(6+\frac45)))}{3(6-2)(2-7)}.
     \end{equation*}
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
(p
 (/ (+ 5
       4
       (- 2
          (- 3
             (+ 6
                (/ 4 5)))))
    (* 3
       (- 6 2)
       (- 2 7)))
 )
</pre></div>

<div class="example">
<pre class="example">

-37/150
</pre></div>

</li><li> Exercise 1.3


<span id="index-1_002e03"></span>
<p>Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">(define (sum-of-squares x y)
  (+ (square x)
     (square y)))

(define (bigger x y)
  (if (&gt; x y)
      x
      y))

(define (smaller x y)
  (if (&gt; x y)
      y
      x))

(define (bigger-sum-of-squares x y z)
  (sum-of-squares (bigger x y)
                  (bigger (smaller x y) z)))
</pre></div>

<div class="example">
<pre class="example">(p (bigger-sum-of-squares 1 2 3))
</pre></div>

<div class="example">
<pre class="example">

13
</pre></div>

</li><li> Exercise 1.4


<span id="index-1_002e04"></span>
<p>Observe that our model of evaluation allows for combinations whose operators are compound expressions. Use this observation to describe the behavior of the following procedure:
</p>
<div class="example">
<pre class="example">(define (a-plus-abs-b a b)
  ((if (&gt; b 0) + -) a b))
</pre></div>

<p><strong>Solution</strong>
</p>
<p>\begin{equation*}
       a + |b|
     \end{equation*}
</p>
</li><li> Exercise 1.5


<span id="index-1_002e05"></span>
<p>Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using applicative-order evaluation or normal-order evaluation. He defines the following two procedures:
</p>
<div class="example">
<pre class="example">(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
</pre></div>

<p>Then he evaluates the expression
</p>
<div class="example">
<pre class="example">(test 0 (p))
</pre></div>

<p>What behavior will Ben observe with an interpreter that uses applicative-order evaluation? What behavior will he observe with an interpreter that uses normal-order evaluation? Explain your answer. (Assume that the evaluation rule for the special form if is the same whether the interpreter is using normal or applicative order: The predicate expression is evaluated first, and the result determines whether to evaluate the consequent or the alternative expression.)
</p>
<p><strong>Solution</strong>
</p>
<p>Using applicative-order evaluation, the evaluation of (test 0 (p)) never terminates. Using normal-order evaluation, the expression evaluates to 0.
</p></li></ol>

<hr>
<span id="Example-Square-Roots-by-Newton_0027s-Method"></span><div class="header">
<p>
Next: <a href="#Procedures-as-Black_002dBox-Abstractions" accesskey="n" rel="next">Procedures as Black-Box Abstractions</a>, Previous: <a href="#Conditional-Expressions-and-Predicates" accesskey="p" rel="prev">Conditional Expressions and Predicates</a>, Up: <a href="#Elements-of-Programming" accesskey="u" rel="up">Elements of Programming</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Example-Square-Roots-by-Newton_0027s-Method-1"></span><h4 class="subsection">1.1.7 Example Square Roots by Newton&rsquo;s Method</h4>

<ul>
<li> What&rsquo;s the contrast between function and procedure?

<p>The contrast between function and procedure is a reflection of the general distinction between describing properties of things and describing how to do things, or, as it is sometimes referred to, the distinction between declarative knowledge and imperative knowledge. In mathematics we are usually concerned with declarative (what is) descriptions, whereas in computer science we are usually concerned with imperative (how to) descriptions.
</p></li></ul>


<div class="float"><span id="newton_002dsqrt"></span>
<div class="example">
<pre class="example">(define (average x y) (/ (+ x y) 2))

(define (improve guess x)
  (average guess (/ x guess)))

(define (good-enough? guess x)
  (&lt; (abs (- (square guess) x)) 0.001))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(define (sqrt x)
  (sqrt-iter 1.0 x))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.1: </strong>Newton&rsquo;s method of successive approximations</p></div></div>
<ol>
<li> Exercise 1.6


<span id="index-1_002e06"></span>
<p>Alyssa P. Hacker doesn’t see why if needs to be provided as a special form. “Why can’t I just define it as an ordinary procedure in terms of <code>cond</code>?” she asks. Alyssa’s friend Eva Lu Ator claims this can indeed be done, and she defines a new version of <code>if</code>:
</p>
<div class="example">
<pre class="example">(define (new-if predicate
                then-clause
                else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
</pre></div>

<p>Eva demonstrates the program for Alyssa:
</p>
<div class="example">
<pre class="example">(new-if (= 2 3) 0 5)
5

(new-if (= 1 1) 0 5)
0
</pre></div>

<p>Delighted, Alyssa uses new-if to rewrite the square-root program:
</p>
<div class="example">
<pre class="example">(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
</pre></div>

<p>What happens when Alyssa attempts to use this to compute square roots? Explain.
</p>
<p><strong>Solution</strong>
</p>
<p>Use of <code>define</code> rather than special forms causes all arguments to be evaluated.
</p>
</li><li> Exercise 1.7


<span id="index-1_002e07"></span>
<p>The <code>good-enough?</code> test used in computing square roots will not be very effective for finding the square roots of very small numbers. Also, in real computers, arithmetic operations are almost always performed with limited precision. This makes our test inadequate for very large numbers. Explain these statements, with examples showing how the test fails for small and large numbers. An alternative strategy for implementing <code>good-enough?</code> is to watch how guess changes from one iteration to the next and to stop when the change is a very small fraction of the guess. Design a square-root procedure that uses this kind of end test. Does this work better for small and large numbers?
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">(define (good-enough? old-guess new-guess)
  (&gt; 0.01
     (/ (abs (- new-guess old-guess))
        old-guess)))

(define (sqrt-iter guess x)
  (if (good-enough? guess (improve guess x))
      (improve guess x)
      (sqrt-iter (improve guess x)
                 x)))
</pre></div>

<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;newton-sqrt&gt;&gt;
&lt;&lt;exercise-1-7&gt;&gt;
(p (sqrt 2))
</pre></div>

</li><li> Exercise 1.8


<span id="index-1_002e08"></span>
<p>Newton’s method for cube roots is based on the fact that if \( y \) is an approximation to the cube root of \( x \) , then a better approximation is given by the value
</p>
<p>\begin{equation*}
       \frac{x/y^2+2y}{3}.
     \end{equation*}
</p>
<p>Use this formula to implement a cube-root procedure analogous to the square-root procedure. (In 1.3.4 we will see how to implement Newton’s method in general as an abstraction of these square-root and cube-root procedures.)
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">(define (improve guess target)
  (/ (+ (/ target (square guess))
        (* 2 guess))
     3))

(define (good-enough? new-guess guess)
  (&lt; (abs (/ (- new-guess guess)
             guess))
     0.01))

(define (cubert-iter guess target)
  (if (good-enough? (improve guess target) guess)
      (improve guess target)
      (cubert-iter (improve guess target)
                   target)))

(define (cubert x)
  (cubert-iter 1.0 x))
</pre></div>

<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-8&gt;&gt;
(p (cubert 2))
</pre></div>
</li></ol>

<hr>
<span id="Procedures-as-Black_002dBox-Abstractions"></span><div class="header">
<p>
Previous: <a href="#Example-Square-Roots-by-Newton_0027s-Method" accesskey="p" rel="prev">Example Square Roots by Newton's Method</a>, Up: <a href="#Elements-of-Programming" accesskey="u" rel="up">Elements of Programming</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Procedures-as-Black_002dBox-Abstractions-1"></span><h4 class="subsection">1.1.8 Procedures as Black-Box Abstractions</h4>

<span id="index-lexical-scoping"></span>
<span id="index-dynamic-scope"></span>

<dl compact="compact">
<dt>lexical scoping</dt>
<dd><p>free variables in a procedure are taken to refer to bindings made by enclosing procedure definitions; that is, they are looked up in the environment in which the procedure was defined. We will see how this works in detail in chapter 3 when we study environments and the detailed behavior of the interpreter. <a href="https://stackoverflow.com/a/1047491">Difference between Lexical scope and dynamic scope</a>
</p></dd>
</dl>

<hr>
<span id="Procedures-and-the-Processes-They-Generate"></span><div class="header">
<p>
Next: <a href="#Formulating-Abstractions-with-Higher_002dOrder-Procedures" accesskey="n" rel="next">Formulating Abstractions with Higher-Order Procedures</a>, Previous: <a href="#Elements-of-Programming" accesskey="p" rel="prev">Elements of Programming</a>, Up: <a href="#Building-Abstractions-with-Procedures" accesskey="u" rel="up">Building Abstractions with Procedures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Procedures-and-the-Processes-They-Generate-1"></span><h3 class="section">1.2 Procedures and the Processes They Generate</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Linear-Recursion-and-Iteration" accesskey="1">Linear Recursion and Iteration</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tree-Recursion" accesskey="2">Tree Recursion</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Orders-of-Growth" accesskey="3">Orders of Growth</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Exponentiation" accesskey="4">Exponentiation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Greatest-Common-Divisors" accesskey="5">Greatest Common Divisors</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Example-Testing-for-Primality" accesskey="6">Example Testing for Primality</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Linear-Recursion-and-Iteration"></span><div class="header">
<p>
Next: <a href="#Tree-Recursion" accesskey="n" rel="next">Tree Recursion</a>, Up: <a href="#Procedures-and-the-Processes-They-Generate" accesskey="u" rel="up">Procedures and the Processes They Generate</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Linear-Recursion-and-Iteration-1"></span><h4 class="subsection">1.2.1 Linear Recursion and Iteration</h4>

<span id="index-recursive-process"></span>
<span id="index-iterative-process"></span>
<span id="index-tail-recursive"></span>

<p>\begin{equation*}
      n!=n\cdot[(n-1)\cdot(n-2) \cdots 3\cdot2\cdot1]=n\cdot(n-1)!
    \end{equation*}
</p>
<div class="example">
<pre class="example">(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
</pre></div>

<div class="example">
<pre class="example">(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (&gt; counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
</pre></div>

<dl compact="compact">
<dt>recursive process</dt>
<dd><p>characterized by a chain of deferred operations.
</p>
</dd>
<dt>iterative process</dt>
<dd><p>state can be summarized by a fixed number of state variables, together with a fixed rule that describes how the state variables should be updated as the process moves from state to state and an (optional) end test that specifies conditions under which the process should terminate.
</p></dd>
</dl>


<ul>
<li> What&rsquo;s the contrast between the two processes?

<p>In the iterative case, the program variables provide a complete description of the state of the process at any point. If we stopped the computation between steps, all we would need to do to resume the computation is to supply the interpreter with the values of the three program variables. Not so with the recursive process. In this case there is some additional “hidden” information, maintained by the interpreter and not contained in the program variables, which indicates “where the process is” in negotiating the chain of deferred operations. The longer the chain, the more information must be maintained.
</p>
</li><li> What&rsquo;s the difference between recursive process and procedure?

<p>When we describe a procedure as recursive, we are referring to the syntactic fact that the procedure definition refers (either directly or indirectly) to the procedure itself. But when we describe a process as following a pattern that is, say, linearly recursive, we are speaking about how the process evolves, not about the syntax of how a procedure is written.
</p>
</li><li> What&rsquo;s tail-recursive?

<p>An iterative process is executed in constant space, even if the iterative process is described by a recursive procedure.
</p></li></ul>

<ol>
<li> Exercise 1.9


<span id="index-1_002e09"></span>
<p>Each of the following two procedures defines a method for adding two positive integers in terms of the procedures inc, which increments its argument by 1, and dec, which decrements its argument by 1.
</p>
<div class="example">
<pre class="example">(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
</pre></div>

<p>Using the substitution model, illustrate the process generated by each procedure in evaluating <code>(+ 4 5)</code>. Are these processes iterative or recursive?
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">;; recursive
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9

;; iterative
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
</pre></div>

</li><li> Exercise 1.10


<span id="index-1_002e10"></span>
<p>The following procedure computes a mathematical function called Ackermann’s function.
</p>
<div class="example">
<pre class="example">(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
</pre></div>

<p>What are the values of the following expressions?
</p>
<div class="example">
<pre class="example">(A 1 10)
(A 2 4)
(A 3 3)
</pre></div>

<p>Consider the following procedures, where A is the procedure defined above:
</p>
<div class="example">
<pre class="example">(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
</pre></div>

<p>Give concise mathematical definitions for the functions computed by the procedures <code>f</code>, <code>g</code>, and <code>h</code> for positive integer values of \( n \). For example, <code>(k n)</code> computes \( 5n^2. \)
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">(A 1 10)
(A 0 (A 1 9))
;; ...
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
;; ...
;; 2^10

(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 4))
(A 1 16)
;; 2^16

(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1)))
(A 2 (A 1 2))
(A 2 4)
;; 2^16
</pre></div>

<p><code>(f n)</code> computes \( 2n \). <code>(g n)</code> computes \( 2^n \). <code>(h n)</code> computes \( 2^{2^n} \).
</p></li></ol>

<hr>
<span id="Tree-Recursion"></span><div class="header">
<p>
Next: <a href="#Orders-of-Growth" accesskey="n" rel="next">Orders of Growth</a>, Previous: <a href="#Linear-Recursion-and-Iteration" accesskey="p" rel="prev">Linear Recursion and Iteration</a>, Up: <a href="#Procedures-and-the-Processes-They-Generate" accesskey="u" rel="up">Procedures and the Processes They Generate</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Tree-Recursion-1"></span><h4 class="subsection">1.2.2 Tree Recursion</h4>

<div class="example">
<pre class="example">(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
</pre></div>

<p>\begin{array}{ccc}
      F(n) &amp;= F(n-1) &amp;+ F(n-2) \\
      &amp; a &amp; b \\
      a^\prime=a+b &amp; b^\prime=a &amp; \\
    \end{array}
</p>
<div class="example">
<pre class="example">(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
</pre></div>

<p>The number of ways to change amount \( a \) using \( n \) kinds of coins equals
</p><ul>
<li> the number of ways to change amount \( a \) using all but the first kind of coin, plus
</li><li> the number of ways to change amount \( a-d \) using all \( n \) kinds of coins, where \( d \) is the denomination of the first kind of coin.
</li></ul>


<p>\begin{equation*}
      C(a, n) = C(a, n-1) + C(a-d, n)
    \end{equation*}
</p>
<div class="float"><span id="count_002dchange"></span>
<div class="example">
<pre class="example">(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (&lt; amount 0)
             (= kinds-of-coins 0))
         0)
        (else
         (+ (cc amount (- kinds-of-coins 1))
            (cc (- amount (first-denomination
                           kinds-of-coins))
                kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.2: </strong>Counting change</p></div></div>
<ol>
<li> Exercise 1.11


<span id="index-1_002e11"></span>
<p>A function \( f \) is defined by the rule that \( f (n) = n \) if \( n &lt;3 \) and \( f (n) = f (n - 1) + 2 f (n - 2) + 3 f (n - 3) \) if \( n \ge 3 \) . Write a procedure that computes \( f \) by means of a recursive process. Write a procedure that computes \( f \) by means of an iterative process.
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">(define (fr n)
  (cond ((&lt; n 3) n)
        (else (+ (fr (- n 1))
                 (* 2 (fr (- n 2)))
                 (* 3 (fr (- n 3)))))))
</pre></div>

<p>\begin{array}{cccc}
       f(n) &amp;= f(n-1) &amp;+ 2f(n-2) &amp;+ 3f(n-3) \\
       &amp; a &amp; b &amp; c \\
       a^\prime=a+2b+3c &amp; b^\prime=a &amp; c^\prime=b &amp; \\
     \end{array}
</p>
<div class="example">
<pre class="example">(define (fi n)
  (fi-iter 0 1 2 n))

(define (fi-iter a b c count)
  (if (= count 0)
      c
      (fi-iter (+ (* 3 a) (* 2 b) c)
               a
               b
               (- count 1))))
</pre></div>

</li><li> Exercise 1.12


<span id="index-1_002e12"></span>
<p>The following pattern of numbers is called Pascal’s triangle.
</p>
<p>\begin{array}{ccccccccc}
       &amp;&amp;&amp;&amp;1&amp;&amp;&amp;&amp; \\
       &amp;&amp;&amp;1&amp;&amp;1&amp;&amp;&amp; \\
       &amp;&amp;1&amp;&amp;2&amp;&amp;1&amp;&amp; \\
       &amp;1&amp;&amp;3&amp;&amp;3&amp;&amp;1&amp; \\
       1&amp;&amp;4&amp;&amp;6&amp;&amp;4&amp;&amp;1 \\
       &amp;&amp;&amp;&amp;\dotsc&amp;&amp;&amp;&amp; \\
     \end{array}
</p>
<p>The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it. Write a procedure that computes elements of Pascal’s triangle by means of a recursive process.
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">(define (pascal-triangle row column)
  (cond ((= row 1) 1)
        ((= column 1) 1)
        ((= row column) 1)
        (else (+ (pascal-triangle (- row 1) (- column 1))
                 (pascal-triangle (- row 1) column)))))
</pre></div>

<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-12&gt;&gt;
(p (pascal-triangle 5 2))
(p (pascal-triangle 5 3))
</pre></div>

</li><li> Exercise 1.13


<span id="index-1_002e13"></span>
<p>Prove that \( Fib(n) \) is the closest integer to \( \varphi^n / \sqrt{5} \), where \( \varphi = (1+\sqrt{5})/2 \). Hint: Let \( \psi = (1-\sqrt{5})/2 \). Use induction and the definition of the Fibonacci numbers (see <a href="#Tree-Recursion">Tree Recursion</a>) to prove that \( Fib(n)=(\varphi^n - \psi^n)/\sqrt{5} \).
</p>
<p><strong>Solution</strong>
</p>
<p>Let&rsquo;s prove \( Fib(n)=\frac{\varphi^n - \psi^n}{\sqrt{5}} \) first.
</p>
<p>Base case:
</p>
<p>\begin{equation*}
       Fib(0)=\frac{\varphi^0 - \psi^0}{\sqrt{5}} = 0.
     \end{equation*}
</p>
<p>Inductive step:
</p>
<p>Assume \( Fib(n)=\frac{\varphi^n - \psi^n}{\sqrt{5}} \), it follows that:
</p>
<p>\begin{align*}
     F(n+1) &amp;\overset{\text{根据Fib定义}}{=} Fib(n) + Fib(n-1) \\
     &amp;= \frac{\varphi^n - \psi^n}{\sqrt{5}} + \frac{\varphi^{n-1} - \psi^{n-1}}{\sqrt{5}} \\
     &amp;= \frac{(1+\frac{1}{\varphi})\varphi^n - (1+\frac{1}{\psi})\psi^n}{\sqrt{5}} \\
     &amp;= \frac{\varphi^{n+1} - \psi^{n+1}}{\sqrt{5}}.
     \end{align*}
</p>
<p>Then prove \( Fib(n) \) is the closest integer to \( \frac{\varphi^n}{\sqrt{5}} \), i.e. \( |Fib(n)-\frac{\varphi^n}{\sqrt{5}}| &lt; \frac12 \).
</p>
<p>\begin{align*}
     |Fib(n)-\frac{\varphi^n}{\sqrt{5}}| = |-\frac{\psi^n}{\sqrt{5}}|
     \end{align*}
</p>

<p>Because \( \frac{1}{\sqrt{5}}&lt;\frac12 \), \( \psi &lt;1 \), so \( |-\frac{\psi^n}{\sqrt{5}}| &lt; \frac12 \).
</p>
<p>Proved.
</p></li></ol>

<hr>
<span id="Orders-of-Growth"></span><div class="header">
<p>
Next: <a href="#Exponentiation" accesskey="n" rel="next">Exponentiation</a>, Previous: <a href="#Tree-Recursion" accesskey="p" rel="prev">Tree Recursion</a>, Up: <a href="#Procedures-and-the-Processes-They-Generate" accesskey="u" rel="up">Procedures and the Processes They Generate</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Orders-of-Growth-1"></span><h4 class="subsection">1.2.3 Orders of Growth</h4>

<span id="index-order-of-growth"></span>

<ul>
<li> What is the purpose of the notion of order of growth?

<p>To obtain a gross measure of the resources required by a process as the inputs become larger.
</p>
</li><li> Let \( n \) be a parameter that measures the size of the problem, and let \( R(n) \) be the amount of resources the process requires for a problem of size \( n \). Give some examples.

<p>If our goal is to compute an approximation to the square root of a number, we might take \( n \) to be the number of digits accuracy required. For matrix multiplication we might take \( n \) to be the number of rows in the matrices. In general there are a number of properties of the problem with respect to which it will be desirable to analyze a given process. Similarly, \( R(n) \) might measure the number of internal storage registers used, the number of elementary machine operations performed, and so on. In computers that do only a fixed number of operations at a time, the time required will be proportional to the number of elementary machine operations performed.
</p>
</li><li> What does it mean that \( R(n) \) has order of growth \( \Theta(f(n)) \)?

<p>For large \( n \) , the value \( R(n) \) is sandwiched between \( k_1f(n) \) and \( k_2f(n) \).
</p>
<table>
<thead><tr><th></th><th>steps</th><th>space</th></tr></thead>
<tr><td>linear factorial</td><td>\(\Theta(n)\)</td><td>\(\Theta(n)\)</td></tr>
<tr><td>iterative factorial</td><td>\(\Theta(n)\)</td><td>\(\Theta(1)\)</td></tr>
<tr><td>tree-recursive Fibonacci</td><td>\(\Theta(\varphi^n)\)</td><td>\(\Theta(n)\)</td></tr>
</table>
</li></ul>

<ol>
<li> Exercise 1.14


<span id="index-1_002e14"></span>
<p>Draw the tree illustrating the process generated by the count-change procedure of <a href="#Tree-Recursion">Tree Recursion</a> in making change for 11 cents. What are the orders of growth of the space and number of steps used by this process as the amount to be changed increases?
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;count-change&gt;&gt;
(p (count-change 11))
</pre></div>

<div class="example">
<pre class="example">

4
</pre></div>


<img src="./omni-exports/exercise-1-14-2x.png" alt="./omni-exports/exercise-1-14-2x">

<p><strong>SPACE</strong>
</p>
<p>The recursive process of <code>cc</code> takes up space proportional to the height of the recursive tree, because at any point in the recursive process we must save all node information from the leaf node to the root node.
</p>
<p>For large n, the height of the recursive tree is dominated by a subtree that recursive minus one, which obviously implies that the height of the recursive tree grows linearly with respect to n, i.e. \( \Theta \left(n\right) \).
</p>
<p><strong>STEPS</strong>
</p>
<p>First we consider the case where only coins of denomination 1 are used.
</p>
<img src="images/exercise-1-14-8621dec.svg" alt="images/exercise-1-14-8621dec">


<p>The height of this recursive tree is \( n \), so the time required is \( T(n,1)=2n+1 \).
</p>
<p>Then we consider the case where coins of denomination 5 and 1 are used.
</p>
<img src="images/exercise-1-14-b369c2a.svg" alt="images/exercise-1-14-b369c2a">

<p>To figure out the height of this recursive tree, consider the special case of <code>(cc 11 2)</code>.
</p>
<img src="images/exercise-1-14-708cd23.svg" alt="images/exercise-1-14-708cd23">

<p>Height is \( \lceil 11/5 \rceil = 3 \).
</p>
<p>So \( T(n,2)= \left\lceil \frac{n}{5} \right\rceil T(n,1) + \left\lceil \frac{n}{5} \right\rceil + 1 \).
</p>
<p>The use of 3 coins is similar to the use of 2 coins, which leads to \( T(n,k) = \left\lceil \frac{n}{D_k} \right\rceil T(n, k-1) + \left\lceil \frac{n}{D_k} \right\rceil + 1 = \Theta(n^k) \).
</p>
</li><li> Exercise 1.15


<span id="index-1_002e15"></span>
<p>The sine of an angle (specified in radians) can be computed by making use of the approximation \( sinx \approx x \) if \( x \) is sufficiently small, and the trigonometric identity
</p>
<p>\begin{equation*}
       \sin x = 3 \sin \frac{x}{3} - 4 \sin^3 \frac{x}{3}
     \end{equation*}
</p>
<p>to reduce the size of the argument of sin. (For purposes of this exercise an angle is considered “sufficiently small” if its magnitude is not greater than 0.1 radians.) These ideas are incorporated in the following procedures:
</p>
<div class="example">
<pre class="example">(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (&gt; (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
</pre></div>

<ol>
<li> How many times is the procedure p applied when <code>(sine 12.15)</code> is evaluated?
</li><li> What is the order of growth in space and number of steps (as a function of \( a \)) used by the process generated by the sine procedure when <code>(sine a)</code> is evaluated?
</li></ol>


<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">(sine 12.15)
(p (sine 4.05))
(p (p (sine 1.35)))
(p (p (p (sine 0.45))))
(p (p (p (p (sine 0.15)))))
(p (p (p (p (p (sine 0.05))))))
(p (p (p (p (p 0.05)))))
</pre></div>

<p>The number of times procedure <code>p</code> has been applied is \( \lceil \log_3 10*a \rceil \), i.e. 5.
</p>
<p>So the order of growth in space and number of steps is \( \Theta(\log a) \).
</p></li></ol>

<hr>
<span id="Exponentiation"></span><div class="header">
<p>
Next: <a href="#Greatest-Common-Divisors" accesskey="n" rel="next">Greatest Common Divisors</a>, Previous: <a href="#Orders-of-Growth" accesskey="p" rel="prev">Orders of Growth</a>, Up: <a href="#Procedures-and-the-Processes-They-Generate" accesskey="u" rel="up">Procedures and the Processes They Generate</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Exponentiation-1"></span><h4 class="subsection">1.2.4 Exponentiation</h4>

<p>Recursive definition:
</p>
<p>\begin{align*}
      b^n &amp;=  b \cdot b^{n-1}, \\
      b^0 &amp;= 1.
    \end{align*}
</p>
<div class="example">
<pre class="example">(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
</pre></div>

<p>This is a linear recursive process, which requires \( \Theta(n) \) steps and \( \Theta(n) \) space.
</p>
<p>Successive squaring:
</p>
<p>\begin{align*}
      b^n &amp;= (b^{n/2})^2 \ \text{if $n$ is even}, \\
      b^n &amp;= b \cdot b^{n-1} \ \text{if $n$ is odd}.
    \end{align*}
</p>
<div class="float"><span id="fast_002dexpt"></span>
<div class="example">
<pre class="example">(define (fast-expt b n)
  (cond ((= n 0)
         1)
        ((even? n)
         (square (fast-expt b (/ n 2))))
        (else
         (* b (fast-expt b (- n 1))))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.3: </strong>fast-expt</p></div></div>
<p>The process has \( \Theta(\log n) \) growth.
</p>
<ol>
<li> Exercise 1.16


<span id="index-1_002e16"></span>
<span id="index-invariant-quantity"></span>
<p>Design a procedure that evolves an iterative exponentiation process that uses successive squaring and uses a logarithmic number of steps, as does fast-expt. (Hint: Using the observation that \( (b^{n/2})^2=(b^2)^{n/2} \), keep, along with the exponent n and the base b, an additional state variable a, and define the state transformation in such a way that the product \( ab^n \) is unchanged from state to state. At the beginning of the process \( a \) is taken to be 1, and the answer is given by the value of \( a \) at the end of the process. In general, the technique of defining an <em>invariant quantity</em> that remains unchanged from state to state is a powerful way to think about the design of iterative algorithms.)
</p>
<p><strong>Solution</strong>
</p><div class="float"><span id="exercise_002d1_002d16"></span>
<div class="example">
<pre class="example">(define (fast-expt b n)
  (iter 1 b n))

(define (iter a b n)
  (cond ((= n 0) a)
        ((even? n) (iter a (square b) (/ n 2)))
        (else (iter (* a b) b (- n 1)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.4: </strong>exercise-1-16</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-16&gt;&gt;
(p (fast-expt 2 3))
</pre></div>

<div class="example">
<pre class="example">

8
</pre></div>

</li><li> Exercise 1.17


<span id="index-1_002e17"></span>
<p>The exponentiation algorithms in this section are based on performing exponentiation by means of repeated multiplication. In a similar way, one can perform integer multiplication by means of repeated addition. The following multiplication procedure (in which it is assumed that our language can only add, not multiply) is analogous to the <code>expt</code> procedure:
</p>
<div class="example">
<pre class="example">(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
</pre></div>

<p>This algorithm takes a number of steps that is linear in \( b \). Now suppose we include, together with addition, operations <code>double</code>, which doubles an integer, and <code>halve</code>, which divides an (even) integer by 2. Using these, design a multiplication procedure analogous to <code>fast-expt</code> that uses a logarithmic number of steps.
</p>
<p><strong>Solution</strong>
</p><div class="float"><span id="exercise_002d1_002d17"></span>
<div class="example">
<pre class="example">(define (* a b)
  (cond ((= b 1) a)
        ((even? b) (* (double a) (halve b)))
        (else (+ a (* a (- b 1))))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.5: </strong>exercise-1-17</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
(define (double x) (+ x x))
(define (halve x) (/ x 2))
&lt;&lt;exercise-1-17&gt;&gt;
(p (* 3 4))
</pre></div>

<div class="example">
<pre class="example">

12
</pre></div>

</li><li> Exercise 1.18


<span id="index-1_002e18"></span>
<p>Using the results of Exercise 1.16 and Exercise 1.17, devise a procedure that generates an iterative process for multiplying two integers in terms of adding, doubling, and halving and uses a logarithmic number of steps.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d18"></span>
<div class="example">
<pre class="example">(define (* a b)
  (iter a b))
(define (iter a b)
  (cond ((= b 1) a)
        ((even? b) (iter (double a) (halve b)))
        (else (iter (+ a a) (- b 1)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.6: </strong>exercise-1-18</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
(define (double x) (+ x x))
(define (halve x) (/ x 2))
&lt;&lt;exercise-1-18&gt;&gt;
(p (* 3 4))
</pre></div>

<div class="example">
<pre class="example">

12
</pre></div>

</li><li> Exercise 1.19


<span id="index-1_002e19"></span>
<span id="index-logarithmic-fibonacci-_0028linear-transformation_0029"></span>
<p>There is a clever algorithm for computing the Fibonacci numbers in a logarithmic number of steps. Recall the transformation of the state variables \( a \) and \( b \) in the <code>fib-iter</code> process of <a href="#Tree-Recursion">Tree Recursion</a>: \( a \gets a+b \) and \( b \gets a \). Call this transformation \( T \), and observe that applying \( T \) over and over again \( n \) times, starting with 1 and 0, produces the pair \( \operatorname{Fib}(n+1) \) and \( \operatorname{Fib}(n) \). In other words, the Fibonacci numbers are produced by applying \( T^n \), the \( n^{th} \) power of the transformation \( T \), starting with the pair \( (1, 0) \). Now consider \( T \) to be the special case of \( p=0 \) and \( q=1 \) in a family of transformations \( T_{pq} \), where \( T_{pq} \) transforms the pair \( (a,b) \) according to \( a \gets bq+aq+ap \) and \( b \gets bp+aq \). Show that if we apply such a transformation \( T_{pq} \) twice, the effect is the same as using a single transformation \( T_{p^\prime q^\prime} \) of the same form, and compute \( p^\prime \) and \( q^\prime \) in terms of \( p \) and \( q \). This gives us an explicit way to square these transformations, and thus we can compute \( T^n \) using successive squaring, as in the fast-expt procedure. Put this all together to complete the following procedure, which runs in a logarithmic number of steps:
</p>
<div class="example">
<pre class="example">(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   ⟨??⟩  ;compute p'
                   ⟨??⟩  ;compute q'
                   (/ count 2)))
        (else
         (fib-iter (+ (* b q) (* a q) (* a p))
                   (+ (* b p) (* a q))
                   p
                   q
                   (- count 1)))))
</pre></div>

<p><strong>Solution</strong>
</p>
<p>\begin{align*}
       T_{pq} \cdot \begin{bmatrix}
         a \\
         b
       \end{bmatrix}
       &amp;= \begin{bmatrix}
         (p+q)a + qb \\
         qa + pb
       \end{bmatrix} \\
       \implies
       T_{pq}
       &amp;= \begin{bmatrix}
         p+q &amp; q \\
         q &amp; p
       \end{bmatrix}\\
       \therefore T_{pq}(T_{pq}A) &amp;= (T_{pq}T_{pq})A \\
       &amp;= T_{p^\prime q^\prime}A \\
       &amp;= \begin{bmatrix}
         p^2 + 2pq + 2q^2 &amp; 2pq + q^2 \\
         2pq + q^2 &amp; p^2 + q^2
       \end{bmatrix} \cdot
       \begin{bmatrix}
         a \\
         b
       \end{bmatrix} \\
       &amp;= \begin{bmatrix}
         (p^2 + 2pq + 2q^2)a + (2pq + q^2)b \\
         (2pq + q^2)a + (p^2 + q^2)b
       \end{bmatrix} \\
       p^\prime &amp;= p^2 + q^2 \\
       q^\prime &amp;= 2pq + q^2
     \end{align*}
</p>
<div class="float"><span id="exercise_002d1_002d19"></span>
<div class="example">
<pre class="example">(define (fib n)
  (fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (square p) (square q))
                   (+ (* 2 p q) (square q))
                   (/ count 2)))
        (else
         (fib-iter (+ (* b q) (* a q) (* a p))
                   (+ (* b p) (* a q))
                   p
                   q
                   (- count 1)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.7: </strong>exercise-1-19</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-19&gt;&gt;
(p (fib 0))
(p (fib 1))
(p (fib 2))
(p (fib 3))
(p (fib 4))
(p (fib 5))
</pre></div>

<div class="example">
<pre class="example">

0
1
1
2
3
5
</pre></div>
</li></ol>

<hr>
<span id="Greatest-Common-Divisors"></span><div class="header">
<p>
Next: <a href="#Example-Testing-for-Primality" accesskey="n" rel="next">Example Testing for Primality</a>, Previous: <a href="#Exponentiation" accesskey="p" rel="prev">Exponentiation</a>, Up: <a href="#Procedures-and-the-Processes-They-Generate" accesskey="u" rel="up">Procedures and the Processes They Generate</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Greatest-Common-Divisors-1"></span><h4 class="subsection">1.2.5 Greatest Common Divisors</h4>

<span id="index-Euclid_2019s-Algorithm-for-computing-GCD"></span>

<p>Euclid’s Algorithm: \( \operatorname{GCD}(a,b) = \operatorname{GCD}(b,r), \ r = a \% b. \)
</p>
<p>Lame&rsquo;s Theorem: If the process takes \( k \) steps, then \( n = \min(a,b) \geqslant Fib(k) \approx \varphi^k/\sqrt{5}. \) Therefore the number of steps \( k \) grows as the logarithm (to the base \( \varphi = \frac{1+\sqrt{5}}{2} \)) of \( n \). Hence, the order of growth is \( \Theta(\log n) \).
</p>
<div class="example">
<pre class="example">(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
</pre></div>

<ol>
<li> Exercise 1.20


<span id="index-1_002e20"></span>
<p>The process that a procedure generates is of course dependent on the rules used by the interpreter. As an example, consider the iterative <code>gcd</code> procedure given above. Suppose we were to interpret this procedure using normal-order evaluation, as discussed in <a href="#The-Substitution-Model-for-Procedure-Application">The Substitution Model for Procedure Application</a>. (The normal-order-evaluation rule for if is described in Exercise 1.5.) Using the substitution method (for normal order), illustrate the process generated in evaluating <code>(gcd 206 40)</code> and indicate the <code>remainder</code> operations that are actually performed. How many <code>remainder</code> operations are actually performed in the normal-order evaluation of <code>(gcd 206 40)</code>? In the applicative-order evaluation?
</p>
<div class="example">
<pre class="example">;;; normal-order, 18 times in total
(gcd 206 40)
;; compare b to 0, compute b, 1 time
(gcd 40 (remainder 206 40))
;; compare b to 0, compute b, 2 times
(gcd (remainder 206 40)
     (remainder 40 (remainder 206 40)))
;; compare b to 0, compute b, 4 times
(gcd (remainder 40 (remainder 206 40))
     (remainder (remainder 206 40)
                (remainder 40 (remainder 206 40))))
;; compare b to 0, compute b, 7 times
;; then compute a as result, 4 times
(gcd (remainder (remainder 206 40)
                (remainder 40 (remainder 206 40)))
     (remainder (remainder 40 (remainder 206 40))
                (remainder (remainder 206 40)
                           (remainder 40 (remainder 206 40)))))

;;; applicative-order, 4 times in total
(gcd 206 40)
(gcd 40 (remainder 206 40)) ;=&gt; (gcd 40 6)
(gcd 6 (remainder 40 6)) ;=&gt; (gcd 6 4)
(gcd 4 (remainder 6 4)) ;=&gt; (gcd 4 2)
(gcd 2 (remainder 4 2)) ;=&gt; (gcd 2 0)
</pre></div>
</li></ol>

<hr>
<span id="Example-Testing-for-Primality"></span><div class="header">
<p>
Previous: <a href="#Greatest-Common-Divisors" accesskey="p" rel="prev">Greatest Common Divisors</a>, Up: <a href="#Procedures-and-the-Processes-They-Generate" accesskey="u" rel="up">Procedures and the Processes They Generate</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Example-Testing-for-Primality-1"></span><h4 class="subsection">1.2.6 Example Testing for Primality</h4>

<span id="index-Fermat_2019s-Little-Theorem"></span>
<span id="index-prime"></span>

<p>Test divisors between \( 1 \) and \( \sqrt{n} \), the number of steps required to identify \( n \) as prime will have order of growth \( \Theta(\sqrt{n}) \).
</p>
<div class="float"><span id="searching_002dfor_002ddivisors"></span>
<div class="example">
<pre class="example">(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((&gt; (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))

;; n is prime if and only if n is its own smallest divisor
(define (prime? n)
  (= n (smallest-divisor n)))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.8: </strong>searching-for-divisors</p></div></div>
<p>Fermat’s Little Theorem: If \( n \) is prime, then \( a^n \equiv a \pmod n, \) \( a \) is positive integer less than \( n \).
</p>
<div class="float"><span id="fermat_002dtest"></span>
<div class="example">
<pre class="example">(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder
          (square (expmod base (/ exp 2) m))
          m))
        (else
         (remainder
          (* base (expmod base (- exp 1) m))
          m))))

(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n)
         (fast-prime? n (- times 1)))
        (else false)))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.9: </strong>fermat-test</p></div></div>
<p>Key points of the fermat test:
</p>
<ul>
<li> <code>Expmod</code> using successive squaring computes \( a^n \) with order of growth \( \Theta(\log n). \)
</li><li> The remainder inside expmod recursion reduces the size of the number. See <a href="#Exercise-125-_00281_0029">Exercise 125 (1)</a>.
</li></ul>

<ol>
<li> Exercise 1.21


<span id="index-1_002e21"></span>
<p>Use the <code>smallest-divisor</code> procedure to find the smallest divisor of each of the following numbers: 199, 1999, 19999.
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;searching-for-divisors&gt;&gt;
(p (smallest-divisor 199))
(p (smallest-divisor 1999))
(p (smallest-divisor 19999))
</pre></div>

</li><li> Exercise 1.22


<span id="index-1_002e22"></span>
<span id="Exercise-122-_00281_0029"></span><p>Most Lisp implementations include a primitive called <code>runtime</code> that returns an integer that specifies the amount of time the system has been running (measured, for example, in microseconds). The following <code>timed-prime-test</code> procedure, when called with an integer \( n \), prints \( n \) and checks to see if \( n \) is prime. If \( n \) is prime, the procedure prints three asterisks followed by the amount of time used in performing the test.
</p>
<div class="example">
<pre class="example">(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
  (display &quot; *** &quot;)
  (display elapsed-time))
</pre></div>

<p>Using this procedure, write a procedure <code>search-for-primes</code> that checks the primality of consecutive odd integers in a specified range. Use your procedure to find the three smallest primes larger than 1000; larger than 10,000; larger than 100,000; larger than 1,000,000. Note the time needed to test each prime. Since the testing algorithm has order of growth of \( \Theta(\sqrt{n}) \), you should expect that testing for primes around 10,000 should take about \( \sqrt{10} \) times as long as testing for primes around 1000. Do your timing data bear this out? How well do the data for 100,000 and 1,000,000 support the \( \Theta(\sqrt{n}) \) prediction? Is your result compatible with the notion that programs on your machine run in time proportional to the number of steps required for the computation?
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d22"></span>
<div class="example">
<pre class="example">(define (timed-prime-test n)
  (let ((start-time (runtime)))
    (if (prime? n)
        (begin
          (newline)
          (display n)
          (display &quot; *** &quot;)
          (display (- (runtime) start-time))
          #t)
        #f)))

(define (search-for-primes n count)
  (if (&gt; count 0)
      (if (odd? n)
          (if (timed-prime-test n)
              (search-for-primes (1+ n) (-1+ count))
              (search-for-primes (1+ n) count))
          (search-for-primes (1+ n) count)))
  'done)
</pre></div>

<div class="float-caption"><p><strong>Listing 1.10: </strong>exercise-1-22</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;searching-for-divisors&gt;&gt;
&lt;&lt;exercise-1-22&gt;&gt;
(search-for-primes 100000000000 3)
(search-for-primes 1000000000000 3)
(search-for-primes 10000000000000 3)
</pre></div>

<div class="example">
<pre class="example">1 ]=&gt; (search-for-primes 100000000000 3)
100000000003 *** .33999999999999997
100000000019 *** .33999999999999997
100000000057 *** .3400000000000001
;Value: done

1 ]=&gt; (search-for-primes 1000000000000 3)
1000000000039 *** 1.06
1000000000061 *** 1.0499999999999998
1000000000063 *** 1.06
;Value: done

1 ]=&gt; (search-for-primes 10000000000000 3)
10000000000037 *** 3.33
10000000000051 *** 3.329999999999999
10000000000099 *** 3.33
;Value: done
</pre></div>

</li><li> Exercise 1.23


<span id="index-1_002e23"></span>
<span id="Exercise-123-_00281_0029"></span><p>The <code>smallest-divisor</code> procedure shown at the start of this section does lots of needless testing: After it checks to see if the number is divisible by 2 there is no point in checking to see if it is divisible by any larger even numbers. This suggests that the values used for test-divisor should not be 2, 3, 4, 5, 6, …, but rather 2, 3, 5, 7, 9, …. To implement this change, define a procedure next that returns 3 if its input is equal to 2 and otherwise returns its input plus 2. Modify the <code>smallest-divisor</code> procedure to use <code>(next test-divisor)</code> instead of <code>(+ test-divisor 1)</code>. With <code>timed-prime-test</code> incorporating this modified version of <code>smallest-divisor</code>, run the test for each of the 12 primes found in <a href="#Exercise-122-_00281_0029">Exercise 122 (1)</a>. Since this modification halves the number of test steps, you should expect it to run about twice as fast. Is this expectation confirmed? If not, what is the observed ratio of the speeds of the two algorithms, and how do you explain the fact that it is different from 2?
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d23"></span>
<div class="example">
<pre class="example">(define (find-divisor n test-divisor)
  (cond ((&gt; (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor)))))

(define (next n)
  (if (= n 2)
      3
      (+ n 2)))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.11: </strong>exercise-1-23</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;searching-for-divisors&gt;&gt;
&lt;&lt;exercise-1-22&gt;&gt;
(search-for-primes 10000000000000 3)
&lt;&lt;exercise-1-23&gt;&gt;
(search-for-primes 10000000000000 3)
</pre></div>

<div class="example">
<pre class="example">1 ]=&gt; (search-for-primes 10000000000000 3)
10000000000037 *** 3.37
10000000000051 *** 3.4899999999999998
10000000000099 *** 3.4399999999999995
;Value: done

1 ]=&gt; (search-for-primes 10000000000000 3)
10000000000037 *** 2.09
10000000000051 *** 2.130000000000001
10000000000099 *** 2.09
;Value: done
</pre></div>

<p>The result is about 1.6 times faster. The comparison in <code>next</code> takes time.
</p>
</li><li> Exercise 1.24


<span id="index-1_002e24"></span>
<span id="Exercise-124-_00281_0029"></span><p>Modify the <code>timed-prime-test</code> procedure of <a href="#Exercise-122-_00281_0029">Exercise 122 (1)</a> to use <code>fast-prime?</code> (the Fermat method), and test each of the 12 primes you found in that exercise. Since the Fermat test has \( \Theta(\log n) \) growth, how would you expect the time to test primes near 1,000,000 to compare with the time needed to test primes near 1000? Do your data bear this out? Can you explain any discrepancy you find?
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d24"></span>
<div class="example">
<pre class="example">(define (prime? n)
  (fast-prime? n 100))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.12: </strong>exercise-1-24</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;fermat-test&gt;&gt;
&lt;&lt;searching-for-divisors&gt;&gt;
&lt;&lt;exercise-1-22&gt;&gt;
&lt;&lt;exercise-1-24&gt;&gt;
(search-for-primes (round-&gt;exact 1e100) 1)
(search-for-primes (round-&gt;exact 1e200) 1)
</pre></div>

<div class="example">
<pre class="example">1 ]=&gt; (search-for-primes (round-&gt;exact 1e100) 1)
10000000000000000159028911097599180468360808563945281389781327557747838772170381060813469985856815251 *** .09
;Value: done

1 ]=&gt; (search-for-primes (round-&gt;exact 1e200) 1)
99999999999999996973312221251036165947450327545502362648241750950346848435554075534196338404706251868027512415973882408182135734368278484639385041047239877871023591066789981811181813306167128854888513 *** .25
;Value: done
</pre></div>

</li><li> Exercise 1.25


<span id="index-1_002e25"></span>
<span id="Exercise-125-_00281_0029"></span><p>Alyssa P. Hacker complains that we went to a lot of extra work in writing <code>expmod</code>. After all, she says, since we already know how to compute exponentials, we could have simply written
</p>
<div class="example">
<pre class="example">(define (expmod base exp m)
  (remainder (fast-expt base exp) m))
</pre></div>

<p>Is she correct? Would this procedure serve as well for our fast prime tester? Explain.
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;fermat-test&gt;&gt;
&lt;&lt;exercise-1-22&gt;&gt;
(define (prime? n)
  (fast-prime? n 100))
;; remainder inside recurrence
(search-for-primes 20000 1)
&lt;&lt;fast-expt&gt;&gt;
&lt;&lt;exercise-1-25-q&gt;&gt;
;; use farst-expt, then remainder
(search-for-primes 20000 1)
</pre></div>


<div class="example">
<pre class="example">1 ]=&gt; ;; remainder inside recurrence
(search-for-primes 20000 1)
20011 *** 0.
;Value: done

1 ]=&gt; ;; use farst-expt, then remainder
(search-for-primes 20000 1)
20011 *** 1.8599999999999999
;Value: done
</pre></div>

<p>Both work, but the remainder within the recursion decreases the size of the number and thus increases efficiency.
</p>
<div class="example">
<pre class="example">(expmod 2 4 3)
(remainder (square (expmod 2 2 3)) 3)
(remainder (square (remainder (square (expmod 2 1 3)) 3)) 3)
(remainder (square (remainder (square (remainder (* 2 (expmod 2 0 3)) 3)) 3)) 3)
(remainder (square (remainder (square (remainder (* 2 1) 3)) 3)) 3)
(remainder (square (remainder (square (remainder 2 3)) 3)) 3)
(remainder (square (remainder (square 2) 3)) 3)
(remainder (square (remainder 4 3)) 3)
(remainder (square 1) 3)
(remainder 1 3)
1

(expmod 2 4 3)
(remainder (fast-expt 2 4) 3)
(remainder (square (fast-expt 2 2)) 3)
(remainder (square (square (fast-expt 2 1))) 3)
(remainder (square (square (* 2 (fast-expt 2 0)))) 3)
(remainder (square (square (* 2 1))) 3)
(remainder (square (square 2)) 3)
(remainder (square 4) 3)
(remainder 16 3)
1
</pre></div>

</li><li> Exercise 1.26


<span id="Exercise-126-_00281_0029"></span><span id="index-1_002e26"></span>
<p>Louis Reasoner is having great difficulty doing <a href="#Exercise-124-_00281_0029">Exercise 124 (1)</a>. His <code>fast-prime?</code> test seems to run more slowly than his <code>prime?</code> test. Louis calls his friend Eva Lu Ator over to help. When they examine Louis’s code, they find that he has rewritten the expmod procedure to use an explicit multiplication, rather than calling square:
</p>
<div class="example">
<pre class="example">(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder
          (* (expmod base (/ exp 2) m)
             (expmod base (/ exp 2) m))
          m))
        (else
         (remainder
          (* base (expmod base (- exp 1) m))
          m))))
</pre></div>

<p>“I don’t see what difference that could make,” says Louis. “I do.” says Eva. “By writing the procedure like that, you have transformed the \( \Theta(\log n) \) process into a \( \Theta(n) \) process.” Explain.
</p>
<p><strong>Solution</strong>
</p>
<p>The rewriting procedure creates a tree recursion, so the order of growth becomes \( \Theta(2^{\log n})=\Theta(n). \)
</p>
</li><li> Exercise 1.27


<span id="index-1_002e27"></span>
<span id="Exercise-127-_00281_0029"></span><p>Demonstrate that the Carmichael numbers listed in Footnote 47 really do fool the Fermat test. That is, write a procedure that takes an integer n and tests whether an is congruent to a modulo n for every a&lt;n, and try your procedure on the given Carmichael numbers.
</p>
<div class="float"><span id="exercise_002d1_002d27"></span>
<div class="example">
<pre class="example">(define (pass-fermat-test? n)
  (newline) (display n) (display &quot; &quot;)
  (define (iter a)
    (cond ((= a 0) #t)
          ((= (expmod a n n) a)
           (iter (- a 1)))
          (else #f)))
  (display (iter (- n 1))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.13: </strong>exercise-1-27</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;fermat-test&gt;&gt;
&lt;&lt;exercise-1-27&gt;&gt;
(map pass-fermat-test? '(561 1105 1729 2465 2821 6601))
</pre></div>

<div class="example">
<pre class="example">

561 #t
1105 #t
1729 #t
2465 #t
2821 #t
6601 #t
</pre></div>

</li><li> Exercise 1.28


<span id="Exercise-128-_00281_0029"></span><span id="index-1_002e28-variant-of-the-Fermat-test"></span>
<span id="index-prime-1"></span>
<p>One variant of the Fermat test that cannot be fooled is called the Miller-Rabin test (Miller 1976; Rabin 1980). This starts from an alternate form of Fermat’s Little Theorem, which states that if n is a prime number and a is any positive integer less than n, then a raised to the \( (n-1) \)-st power is congruent to 1 modulo n. To test the primality of a number n by the Miller-Rabin test, we pick a random number \( a&lt;n \) and raise a to the \( (n-1) \)-st power modulo n using the expmod procedure. However, whenever we perform the squaring step in expmod, we check to see if we have discovered a “nontrivial square root of 1 modulo n,” that is, a number not equal to 1 or \( n-1 \) whose square is equal to 1 modulo n. It is possible to prove that if such a nontrivial square root of 1 exists, then n is not prime. It is also possible to prove that if n is an odd number that is not prime, then, for at least half the numbers \( a&lt;n \), computing \( a^{n−1} \) in this way will reveal a nontrivial square root of 1 modulo n. (This is why the Miller-Rabin test cannot be fooled.) Modify the <code>expmod</code> procedure to signal if it discovers a nontrivial square root of 1, and use this to implement the Miller-Rabin test with a procedure analogous to <code>fermat-test</code>. Check your procedure by testing various known primes and non-primes. Hint: One convenient way to make <code>expmod</code> signal is to have it return 0.
</p>
<p><strong>Solution</strong>
</p>
<p>Miller-Rabin test:
</p>
<p>\( \forall a (a&lt;n \land a^{n-1} \equiv 1 \pmod n) \to n \text{ is prime}. \)
</p>
<p>\( \exists a (a \ne 1 \land a \ne n-1 \land a^2 \equiv 1 \pmod n) \to n \text{ is not prime}. \)
</p>
<span id="index-miller-rabin-test-prime"></span>
<div class="float"><span id="exercise_002d1_002d28_002dprime"></span>
<div class="example">
<pre class="example">(define (sqmod x m)
  &quot;Return x^2 if `x^2 mod m` is not equal to `1 mod m`
 and x != m - 1 and x != 1; 0 otherwise.&quot;
  (let ((square (* x x)))
    (cond ((and  (= (remainder square m) 1) ; 1 mod m = 1
                 (not (= x (- m 1)))
                 (not (= x 1)))
           0)
          (else square))))

(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (sqmod (expmod base (/ exp 2) m) m)
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))

(define (miller-rabin-test? n)
  (define (try-it a)
    (= (expmod a (- n 1) n) 1))
  (try-it (+ 1 (random (- n 1)))))

(define (fast-prime? n times)
  (cond ((= times 0) #t)
        ((miller-rabin-test? n) (fast-prime? n (- times 1)))
        (else #f)))

(define (prime? n)
  (fast-prime? n 100))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.14: </strong>exercise-1-28-prime</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-28-prime&gt;&gt;
(define (test x)
  (newline)
  (display x) (display &quot; &quot;)
  (display (prime? x)))

(map test '(561 1105 1729 2465 2821 6601 7 11))
</pre></div>

<div class="example">
<pre class="example">

561 #f
1105 #f
1729 #f
2465 #f
2821 #f
6601 #f
7 #t
11 #t
</pre></div>
</li></ol>

<hr>
<span id="Formulating-Abstractions-with-Higher_002dOrder-Procedures"></span><div class="header">
<p>
Previous: <a href="#Procedures-and-the-Processes-They-Generate" accesskey="p" rel="prev">Procedures and the Processes They Generate</a>, Up: <a href="#Building-Abstractions-with-Procedures" accesskey="u" rel="up">Building Abstractions with Procedures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Formulating-Abstractions-with-Higher_002dOrder-Procedures-1"></span><h3 class="section">1.3 Formulating Abstractions with Higher-Order Procedures</h3>

<span id="index-procedures"></span>
<span id="index-higher_002dorder-procedures"></span>

<dl compact="compact">
<dt>procedures</dt>
<dd><p>abstractions that describe compound operations on numbers independent of the particular numbers.
</p>
</dd>
<dt>higher-order procedures</dt>
<dd><p>Procedures that manipulate procedures are called higher-order procedures. Procedures that can accept procedures as arguments or return procedures as values.
</p></dd>
</dl>


<ul>
<li> What do compound procedures permit us?

<p>They permit us to express general methods of computing as explicit elements in our programming language.
</p>
</li><li> What do higher-order procedures permit us?

<p>They permit us to manipulate these general methods to create further abstractions.
</p>
</li><li> What ability does procedures provide?

<p>The ability to build abstractions by assigning names to common patterns and then to work in terms of the abstractions directly.
</p>
</li><li> Why is it important to be able to think in terms of these abstractions?

<p>So we can be ready to apply them in new contexts.
</p>
</li><li> What is the significance of higher-order procedures?

<p>That they enable us to represent these abstractions explicitly as elements in our programming language, so that they can be handled just like other computational elements.
</p>
</li><li> What is first-class status?

<p>Elements with the fewest restrictions are said to have first-class status.
</p>
</li><li> What are the rights and privileges of first-class elements?

<ul>
<li> They may be named by variables.
</li><li> They may be passed as arguments to procedures.
</li><li> They may be returned as the results of procedures.
</li><li> They may be included in data structures.
</li></ul>
</li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Procedures-as-Arguments" accesskey="1">Procedures as Arguments</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Constructing-Procedures-Using-Lambda" accesskey="2">Constructing Procedures Using Lambda</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Procedures-as-General-Methods" accesskey="3">Procedures as General Methods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Procedures-as-Returned-Values" accesskey="4">Procedures as Returned Values</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Procedures-as-Arguments"></span><div class="header">
<p>
Next: <a href="#Constructing-Procedures-Using-Lambda" accesskey="n" rel="next">Constructing Procedures Using Lambda</a>, Up: <a href="#Formulating-Abstractions-with-Higher_002dOrder-Procedures" accesskey="u" rel="up">Formulating Abstractions with Higher-Order Procedures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Procedures-as-Arguments-1"></span><h4 class="subsection">1.3.1 Procedures as Arguments</h4>

<span id="index-definite-integral"></span>

<div class="float"><span id="sum"></span>
<div class="example">
<pre class="example">(define (sum term a next b)
  (if (&gt; a b)
      0
      (+ (term a)
         (sum term (next a) next b))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.15: </strong>sum</p></div></div>
<img src="./omni-exports/1-3-1-sum-2x.png" alt="./omni-exports/1-3-1-sum-2x">

<div class="float"><span id="definite_002dintegral"></span>
<div class="example">
<pre class="example">(define (integral f a b dx)
  (define (add-dx x) (+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
     dx))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.16: </strong>definite-integral</p></div></div>
<p>\( \int_a^b f = [f(a + \frac{dx}{2}) + f(a+dx+\frac{dx}{2}) + f(a+2dx+\frac{dx}{2}) + \dotsc]dx \)
</p>
<ol>
<li> Exercise 1.29


<span id="Exercise-129-_00281_0029"></span><span id="index-1_002e29-Simpson_2019s-Rule-of-integration"></span>
<p>Simpson’s Rule is a more accurate method of numerical integration than the method illustrated above. Using Simpson’s Rule, the integral of a function f between a and b is approximated as
\( \frac{h}{3} (y_0+4y_1+2y_2+4y_3+2y_4+ \dotsb +2y_{n-2}+4y_{n-1}+y_n) \),
where \( h=(b-a)/n \), for some even integer n, and \( y_k=f(a+kh) \). (Increasing n increases the accuracy of the approximation.) Define a procedure that takes as arguments f, a, b, and n and returns the value of the integral, computed using Simpson’s Rule. Use your procedure to integrate <code>cube</code> between 0 and 1 (with \( n=100 \) and \( n=1000 \)), and compare the results to those of the <code>integral</code> procedure shown above.
</p>
<p><strong>Solution</strong>
</p>
<p>\( \frac{h}{3}(y_0 + y_n + 4(y_1 + y_3 + \dotsb +y_{n-1})+ 2(y_2 + y_4 +\dotsb + y_{n-2})) \)
</p>
<div class="float"><span id="exercise_002d1_002d29"></span>
<div class="example">
<pre class="example">(define (simpson-integral f a b n)
  (define (h)
    (/ (- b a) n))
  (define (y k)
    (f (+ a (* k (h)))))
  (define (add-two x)
    (+ x 2))
  (* (/ (h) 3)
     (+ (y 0)
        (y n)
        (* 4 (sum y 1 add-two (- n 1)))
        (* 2 (sum y 2 add-two (- n 2))))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.17: </strong>exercise-1-29</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;sum&gt;&gt;
&lt;&lt;definite-integral&gt;&gt;
&lt;&lt;exercise-1-29&gt;&gt;
(p (simpson-integral cube 0.0 1.0 100))
(p (simpson-integral cube 0.0 1.0 1000))
(p (integral cube 0.0 1.0 0.01))
(p (integral cube 0.0 1.0 0.001))
</pre></div>

<div class="example">
<pre class="example">

0.25000000000000006
0.2500000000000002
0.24998750000000042
0.249999875000001
</pre></div>

</li><li> Exercise 1.30


<span id="Exercise-130-_00281_0029"></span><span id="index-1_002e30-iterative-sum"></span>
<p>The <code>sum</code> procedure above generates a linear recursion. The procedure can be rewritten so that the sum is performed iteratively. Show how to do this by filling in the missing expressions in the following definition:
</p>
<div class="example">
<pre class="example">(define (sum term a next b)
  (define (iter a result)
    (if ⟨??⟩
        ⟨??⟩
        (iter ⟨??⟩ ⟨??⟩)))
  (iter ⟨??⟩ ⟨??⟩))
</pre></div>

<p><strong>Solution</strong>
</p><div class="float"><span id="exercise_002d1_002d30"></span>
<div class="example">
<pre class="example">(define (sum term a next b)
  (define (iter a result)
    (if (&gt; a b)
        result
        (iter (next a) (+ result (term a)))))
  (iter a 0))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.18: </strong>exercise-1-30</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-30&gt;&gt;
&lt;&lt;definite-integral&gt;&gt;
(p (integral cube 0.0 1.0 0.01))
</pre></div>

</li><li> Exercise 1.31


<span id="Exercise-131-_00281_0029"></span><span id="index-1_002e31-product-pi"></span>
<ol>
<li> The sum procedure is only the simplest of a vast number of similar abstractions that can be captured as higher-order procedures.51 Write an analogous procedure called product that returns the product of the values of a function at points over a given range. Show how to define factorial in terms of product. Also use product to compute approximations to π using the formula
\[ \frac{\pi}{4}=\frac{2\cdot 4\cdot 4\cdot 6\cdot 6\cdot 8\dotsb}{3\cdot 3\cdot 5\cdot 5\cdot 7\cdot 7\dotsb} \]
</li><li> If your <code>product</code> procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.
</li></ol>


<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d31_002drecur"></span>
<div class="example">
<pre class="example">(define (product term a next b)
  (if (&gt; a b)
      1
      (* (term a)
         (product term (next a) next b))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.19: </strong>exercise-1-31-recur</p></div></div>
<div class="float"><span id="exercise_002d1_002d31_002diter"></span>
<div class="example">
<pre class="example">(define (product term a next b)
  (define (iter a result)
    (if (&gt; a b)
        result
        (iter (next a) (* result (term a)))))
  (iter a 1))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.20: </strong>exercise-1-31-iter</p></div></div>
<div class="float"><span id="exercise_002d1_002d31_002dfactorial"></span>
<div class="example">
<pre class="example">(define (factorial x)
  (product identity 1 add-one x))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.21: </strong>exercise-1-31-factorial</p></div></div>
<div class="float"><span id="exercise_002d1_002d31_002dpi"></span>
<div class="example">
<pre class="example">(define (numer-term x)
  (if (odd? x) (+ x 1) (+ x 2)))
(define (denom-term x)
  (if (odd? x) (+ x 2) (+ x 1)))
(define (pi n)
  (* 4.0 (/ (product numer-term 1 add-one n)
            (product denom-term 1 add-one n))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.22: </strong>exercise-1-31-pi</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-31-recur&gt;&gt;
&lt;&lt;exercise-1-31-factorial&gt;&gt;
&lt;&lt;exercise-1-31-pi&gt;&gt;
(p (factorial 4))
(p (pi 100))
&lt;&lt;exercise-1-31-iter&gt;&gt;
(p (factorial 4))
(p (pi 100))
</pre></div>

<div class="example">
<pre class="example">

24
3.1570301764551676
24
3.1570301764551676
</pre></div>

</li><li> Exercise 1.32


<span id="Exercise-132-_00281_0029"></span><span id="index-1_002e32-accumulate"></span>
<ol>
<li> Show that <code>sum</code> and <code>product</code> (<a href="#Exercise-131-_00281_0029">Exercise 131 (1)</a>) are both special cases of a still more general notion called <code>accumulate</code> that combines a collection of terms, using some general accumulation function:

<div class="example">
<pre class="example">(accumulate
 combiner null-value term a next b)
</pre></div>

<p>Accumulate takes as arguments the same term and range specifications as sum and product, together with a combiner procedure (of two arguments) that specifies how the current term is to be combined with the accumulation of the preceding terms and a null-value that specifies what base value to use when the terms run out. Write accumulate and show how sum and product can both be defined as simple calls to accumulate.
</p>
</li><li> If your <code>accumulate</code> procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.
</li></ol>


<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d32_002drecur"></span>
<div class="example">
<pre class="example">(define (accumulate combiner null-value term a next b)
  (if (&gt; a b)
      null-value
      (combiner
       (term a)
       (accumulate combiner null-value term (next a) next b))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.23: </strong>exercise-1-32-recur</p></div></div>
<div class="float"><span id="exercise_002d1_002d32_002diter"></span>
<div class="example">
<pre class="example">(define (accumulate combiner null-value term a next b)
  (define (iter a result)
    (if (&gt; a b)
        result
        (iter (next a) (combiner result (term a)))))
  (iter a null-value))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.24: </strong>exercise-1-32-iter</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-32-recur&gt;&gt;
(define (sum term a next b)
  (accumulate + 0 term a next b))
(define (product term a next b)
  (accumulate * 1 term a next b))

(p (sum identity 1 add-one 5))
(p (product identity 1 add-one 5))
&lt;&lt;exercise-1-32-iter&gt;&gt;
(p (sum identity 1 add-one 5))
(p (product identity 1 add-one 5))
</pre></div>

<div class="example">
<pre class="example">

15
120
15
120
</pre></div>

</li><li> Exercise 1.33


<span id="Exercise-133-_00281_0029"></span><span id="index-1_002e33-filtered_002daccumulate"></span>
<p>You can obtain an even more general version of <code>accumulate</code> (<a href="#Exercise-132-_00281_0029">Exercise 132 (1)</a>) by introducing the notion of a <em>filter</em> on the terms to be combined. That is, combine only those terms derived from values in the range that satisfy a specified condition. The resulting <code>filtered-accumulate</code> abstraction takes the same arguments as accumulate, together with an additional predicate of one argument that specifies the filter. Write <code>filtered-accumulate</code> as a procedure. Show how to express the following using <code>filtered-accumulate</code>:
</p><ol>
<li> the sum of the squares of the prime numbers in the interval a to b (assuming that you have a <code>prime?</code> predicate already written)
</li><li> the product of all the positive integers less than n that are relatively prime to n (i.e., all positive integers \( i&lt;n \) such that \( \operatorname{GCD}(i,n)=1 \)).
</li></ol>


<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d33_002dfa"></span>
<div class="example">
<pre class="example">(define (filtered-accumulate filter combiner
                             null-value term a next b)
  (cond ((&gt; a b)
         null-value)
        ((filter a)
         (combiner
          (term a)
          (filtered-accumulate filter combiner
                               null-value term
                               (next a) next b)))
        (else
         (filtered-accumulate filter combiner
                              null-value term
                              (next a) next b))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.25: </strong>exercise-1-33-fa</p></div></div>
<div class="float"><span id="exercise_002d1_002d33"></span>
<div class="example">
<pre class="example">(define (sum-prime-squares a b)
  (filtered-accumulate prime? + 0 identity a add-one b))

(define (product-prime-less-than n)
  (define (rel-prime? x)
    (= (gcd x n) 1))
  (filtered-accumulate rel-prime? * 1 identity 1 add-one n))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.26: </strong>exercise-1-33</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-28-prime&gt;&gt;
&lt;&lt;exercise-1-33-fa&gt;&gt;
&lt;&lt;exercise-1-33&gt;&gt;
(p (sum-prime-squares 2 10)) ; 2 3 5 7
(p (product-prime-less-than 8)) ; 1 3 5 7
</pre></div>

<div class="example">
<pre class="example">

17
105
</pre></div>
</li></ol>

<hr>
<span id="Constructing-Procedures-Using-Lambda"></span><div class="header">
<p>
Next: <a href="#Procedures-as-General-Methods" accesskey="n" rel="next">Procedures as General Methods</a>, Previous: <a href="#Procedures-as-Arguments" accesskey="p" rel="prev">Procedures as Arguments</a>, Up: <a href="#Formulating-Abstractions-with-Higher_002dOrder-Procedures" accesskey="u" rel="up">Formulating Abstractions with Higher-Order Procedures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Constructing-Procedures-Using-Lambda-1"></span><h4 class="subsection">1.3.2 Constructing Procedures Using Lambda</h4>

<ul>
<li> What is <code>let</code>?

<p>A let expression is simply syntactic sugar for the underlying lambda application to provide local variables.
</p>
<div class="example">
<pre class="example">(let ((⟨var_1⟩ ⟨exp_1⟩)
      (⟨var_2⟩ ⟨exp_2⟩)
      ...
      (⟨var_n⟩ ⟨exp_n⟩))
  ⟨body⟩)

((lambda (⟨var_1⟩ ... ⟨var_n⟩)
   ⟨body⟩)
 ⟨exp_1⟩
 ...
 ⟨exp_n⟩)
</pre></div>
</li></ul>

<ol>
<li> Exercise 1.34


<span id="Exercise-134-_00281_0029"></span><span id="index-1_002e34"></span>
<p>Suppose we define the procedure
</p><div class="float"><span id="exercise_002d1_002d34_002dq"></span>
<div class="example">
<pre class="example">(define (f g) (g 2))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.27: </strong>exercise-1-34-q</p></div></div><p>Then we have
</p><div class="example">
<pre class="example">(f square)
4

(f (lambda (z) (* z (+ z 1))))
6
</pre></div>
<p>What happens if we (perversely) ask the interpreter to evaluate the combination <code>(f f)</code>? Explain.
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-34-q&gt;&gt;
(f f) ; finally (2 2)
</pre></div>

<div class="example">
<pre class="example">ice-9/boot-9.scm:1669:16: In procedure raise-exception:
Wrong type to apply: 2

Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
scheme@(guile-user) [1]&gt;
</pre></div>
</li></ol>

<hr>
<span id="Procedures-as-General-Methods"></span><div class="header">
<p>
Next: <a href="#Procedures-as-Returned-Values" accesskey="n" rel="next">Procedures as Returned Values</a>, Previous: <a href="#Constructing-Procedures-Using-Lambda" accesskey="p" rel="prev">Constructing Procedures Using Lambda</a>, Up: <a href="#Formulating-Abstractions-with-Higher_002dOrder-Procedures" accesskey="u" rel="up">Formulating Abstractions with Higher-Order Procedures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Procedures-as-General-Methods-1"></span><h4 class="subsection">1.3.3 Procedures as General Methods</h4>

<span id="index-half-interval-method"></span>
<span id="index-fixed-point"></span>
<span id="index-average-damping"></span>

<table>
<tr><td>compound procedure</td><td>independent of the particular numbers</td></tr>
<tr><td>higher-order procedure</td><td>independent of the particular functions</td></tr>
</table>

<span id="index-half_002dinterval_002dmethod"></span>
<div class="float"><span id="half_002dinterval_002dmethod"></span>
<div class="example">
<pre class="example">(define (search f neg-point pos-point)
  (let ((midpoint
         (average neg-point pos-point)))
    (if (close-enough? neg-point pos-point)
        midpoint
        (let ((test-value (f midpoint)))
          (cond
           ((positive? test-value)
            (search f neg-point midpoint))
           ((negative? test-value)
            (search f midpoint pos-point))
           (else midpoint))))))

(define (close-enough? x y)
  (&lt; (abs (- x y)) 0.001))

(define (half-interval-method f a b)
  (let ((a-value (f a))
        (b-value (f b)))
    (cond ((and (negative? a-value)
                (positive? b-value))
           (search f a b))
          ((and (negative? b-value)
                (positive? a-value))
           (search f b a))
          (else
           (error &quot;Values are not of
                   opposite sign&quot; a b)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.28: </strong>half-interval-method</p></div></div>
<p>A number \( x \) is called a fixed point of a function \( f \) if \( x \) satisfies the equation \( f(x)=x \). For some functions \( f \) we can locate a fixed point by beginning with an initial guess and applying \( f \) repeatedly,
    \[ f(x),f(f(x)),f(f(f(x))), \dotsc , \]
until the value does not change very much.
</p>
<span id="index-fixed_002dpoint"></span>
<div class="float"><span id="fixed_002dpoint"></span>
<div class="example">
<pre class="example">(define tolerance 0.00001)

(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (&lt; (abs (- v1 v2))
       tolerance))
  (define (try guess)
    (let ((next (f guess)))
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.29: </strong>fixed-point</p></div></div>
<p>Compute square roots of x by looking for a fixed point of the function \( y \mapsto x/y. \)
</p>
<div class="example">
<pre class="example">(define (sqrt x)
  (fixed-point (lambda (y) (/ x y)) 1.0))
</pre></div>

<p>Use <em>average damping</em> to aid the convergence of fixed-point searches.
</p>
<p>Look for a fixed point of \( y \mapsto \frac12 (y+x/y) \):
</p>
<div class="float"><span id="sqrt_002dfp"></span>
<div class="example">
<pre class="example">(define (sqrt x)
  (fixed-point
   (lambda (y) (average y (/ x y)))
   1.0))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.30: </strong>sqrt-fp</p></div></div>
<ol>
<li> Exercise 1.35


<span id="Exercise-135-_00281_0029"></span><span id="index-1_002e35-golden-ratio"></span>
<p>Show that the golden ratio \( \varphi \) <a href="#Tree-Recursion">Tree Recursion</a> is a fixed point of the transformation \( x \mapsto 1+1/x \), and use this fact to compute \( \varphi \) by means of the fixed-point procedure.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d35"></span>
<div class="example">
<pre class="example">(define (golden-ratio)
  (fixed-point (lambda (x) (+ 1 (/ 1 x)))
               1.0))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.31: </strong>exercise-1-35</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;fixed-point&gt;&gt;
&lt;&lt;exercise-1-35&gt;&gt;
(p (golden-ratio))
</pre></div>

<div class="example">
<pre class="example">

1.6180327868852458
</pre></div>

</li><li> Exercise 1.36


<span id="Exercise-136-_00281_0029"></span><span id="index-1_002e36-with_002fwithout-average-damping"></span>
<p>Modify <code>fixed-point</code> so that it prints the sequence of approximations it generates, using the newline and display primitives shown in <a href="#Exercise-122-_00281_0029">Exercise 122 (1)</a>. Then find a solution to \( x^x=1000 \) by finding a fixed point of \( x \mapsto \log(1000)/\log(x) \). (Use Scheme’s primitive <code>log</code> procedure, which computes natural logarithms.) Compare the number of steps this takes with and without average damping. (Note that you cannot start <code>fixed-point</code> with a guess of 1, as this would cause division by \( \log(1)=0 \).)
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d36_002dfpp"></span>
<div class="example">
<pre class="example">(define count 1)
(define (fixed-point f guess)
  (let ((next-guess (f guess)))
    (newline) (display count)
    (display &quot;: &quot;)(display next-guess)
    (if (&lt; (abs (- next-guess guess)) 0.0001)
        next-guess
        (begin (set! count (+ 1 count))
               (fixed-point f next-guess)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.32: </strong>exercise-1-36-fpp</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-36-fpp&gt;&gt;
(p &quot;without average damping&quot;)
(fixed-point (lambda (x)
               (/ (log 1000) (log x)))
             2)
(p &quot;&quot;)
(p &quot;with average damping&quot;)
(set! count 1)
(fixed-point (lambda (x)
               (/ (+ x (/ (log 1000) (log x))) 2))
             2)

</pre></div>

<div class="example">
<pre class="example">

without average damping
1: 9.965784284662087
2: 3.004472209841214
3: 6.279195757507157
4: 3.759850702401539
5: 5.215843784925895
6: 4.182207192401397
7: 4.8277650983445906
8: 4.387593384662677
9: 4.671250085763899
10: 4.481403616895052
11: 4.6053657460929
12: 4.5230849678718865
13: 4.577114682047341
14: 4.541382480151454
15: 4.564903245230833
16: 4.549372679303342
17: 4.559606491913287
18: 4.552853875788271
19: 4.557305529748263
20: 4.554369064436181
21: 4.556305311532999
22: 4.555028263573554
23: 4.555870396702851
24: 4.555315001192079
25: 4.5556812635433275
26: 4.555439715736846
27: 4.555599009998291
28: 4.555493957531389
29: 4.555563237292884

with average damping
1: 5.9828921423310435
2: 4.922168721308343
3: 4.628224318195455
4: 4.568346513136242
5: 4.5577305909237005
6: 4.555909809045131
7: 4.555599411610624
8: 4.5555465521473675
</pre></div>

</li><li> Exercise 1.37


<span id="Exercise-137-_00281_0029"></span><span id="index-1_002e37-continued-fraction"></span>
<ol>
<li> An infinite <em>continued fraction</em> is an expression of the form
\[ f=\large\frac{N_1}{D_1+\frac{N_2}{D_2+\frac{N_3}{D_3+\cdots}}} \]
As an example, one can show that the infinite continued fraction expansion with the \( N_i \) and the \( D_i \) all equal to 1 produces \( 1/\varphi \), where \( \varphi \) is the golden ratio (described in <a href="#Tree-Recursion">Tree Recursion</a>). One way to approximate an infinite continued fraction is to truncate the expansion after a given number of terms. Such a truncation—a so-called finite continued fraction <em>k-term finite continued fraction</em> —has the form
\[ \large\frac{N_1}{D_1+\frac{N_2}{\ddots+\frac{N_k}{D_k}}} \]
Suppose that n and d are procedures of one argument (the term index i) that return the Ni and Di of the terms of the continued fraction. Define a procedure cont-frac such that evaluating (cont-frac n d k) computes the value of the k-term finite continued fraction. Check your procedure by approximating \( 1/\varphi \) using
<div class="example">
<pre class="example">(cont-frac (lambda (i) 1.0)
           (lambda (i) 1.0)
           k)
</pre></div>
<p>for successive values of k. How large must you make k in order to get an approximation that is accurate to 4 decimal places?
</p></li><li> If your cont-frac procedure generates a recursive process, write one that generates an iterative process. If it generates an iterative process, write one that generates a recursive process.
</li></ol>


<p><strong>Solution</strong>
</p>
<p>The first three fractions:
</p>
<p>\begin{equation*}
       \frac{N_1}{D_1},
       \frac{N_1}{D_1+\frac{N_2}{D_2}},
       \frac{N_1}{D_1+\frac{N_2}{D_2+\frac{N_3}{D_3}}.
     \end{equation*}
</p>
<div class="float"><span id="exercise_002d1_002d37_002drecur"></span>
<div class="example">
<pre class="example">(define (cont-frac n d k)
  (define (recur i)
    (/ (n i)
       (+ (d i)
          (if (= i k)
              0
              (recur (+ i 1))))))
  (recur 1))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.33: </strong>exercise-1-37-recur</p></div></div>
<div class="float"><span id="exercise_002d1_002d37_002diter"></span>
<div class="example">
<pre class="example">(define (cont-frac-iter n d k)
  (define (iter i result)
    (if (= i 0)
        result
        (iter (- i 1)
              (/ (n i) (+ (d i) result)))))
  (iter k 0))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.34: </strong>exercise-1-37-iter</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-37-recur&gt;&gt;
(map (lambda (k)
       (p (cont-frac (lambda (i) 1.0)
                     (lambda (i) 1.0)
                     k)))
     '(5 10 15 20 30))
&lt;&lt;exercise-1-37-iter&gt;&gt;
(map (lambda (k)
       (p (cont-frac (lambda (i) 1.0)
                     (lambda (i) 1.0)
                     k)))
     '(5 10 15 20 30))
</pre></div>

<div class="example">
<pre class="example">

0.625
0.6179775280898876
0.6180344478216819
0.6180339850173578
0.6180339887496482
0.625
0.6179775280898876
0.6180344478216819
0.6180339850173578
0.6180339887496482
</pre></div>

</li><li> Exercise 1.38


<span id="Exercise-138-_00281_0029"></span><span id="index-1_002e38-continued-fraction_002c-Euler_0027s-number"></span>
<p>In 1737, the Swiss mathematician Leonhard Euler published a memoir De Fractionibus Continuis, which included a continued fraction expansion for \( e-2 \), where \( e \) is the base of the natural logarithms. In this fraction, the \( Ni \) are all 1, and the \( Di \) are successively \( 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, \dotsc . \) Write a program that uses your <code>cont-frac</code> procedure from <a href="#Exercise-137-_00281_0029">Exercise 137 (1)</a> to approximate \( e \), based on Euler’s expansion.
</p>
<div class="float"><span id="exercise_002d1_002d38"></span>
<div class="example">
<pre class="example">(define (n i) 1)

(define (d i)
  (let ((quot (quotient (- i 2) 3))
        (rem (remainder (- i 2) 3)))
    (cond ((= i 1) 1)
          ((= i 2) 2)
          ((= rem 1) 1)
          ((= rem 2) 1)
          (else (* (+ quot 1) 2)))))

(define (e)
  (+ (cont-frac n d 11) 2.0))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.35: </strong>exercise-1-38</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-37-recur&gt;&gt;
&lt;&lt;exercise-1-38&gt;&gt;
(p (e))
</pre></div>

<div class="example">
<pre class="example">

2.7182818352059925
</pre></div>

</li><li> Exercise 1.39


<span id="Exercise-139-_00281_0029"></span><span id="index-1_002e39-continued-fraction_002c-tangent"></span>
<p>A continued fraction representation of the tangent function was published in 1770 by the German mathematician J.H. Lambert:
\[ \tan x = \Large\frac{x}{1-\frac{x^2}{3-\frac{x^2}{5-\ddots}}} \]
where x is in radians. Define a procedure <code>(tan-cf x k)</code> that computes an approximation to the tangent function based on Lambert’s formula. k specifies the number of terms to compute, as in <a href="#Exercise-137-_00281_0029">Exercise 137 (1)</a>.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d39"></span>
<div class="example">
<pre class="example">(define (cont-frac n d k combiner)
  (define (recur i)
    (/ (n i)
       (combiner (d i)
                 (if (= i k)
                     0
                     (recur (+ i 1))))))
  (recur 1))

(define (tan-cf x k)
  (define (n i)
    (if (= i 1) x (square x)))
  (define (d i)
    (- (* 2 i) 1))
  (cont-frac n d k -))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.36: </strong>exercise-1-39</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-39&gt;&gt;
(p (tan-cf 2.0 10))
(p (tan 2.0))
</pre></div>

<div class="example">
<pre class="example">

-2.1850398632626273
-2.185039863261519
</pre></div>
</li></ol>

<hr>
<span id="Procedures-as-Returned-Values"></span><div class="header">
<p>
Previous: <a href="#Procedures-as-General-Methods" accesskey="p" rel="prev">Procedures as General Methods</a>, Up: <a href="#Formulating-Abstractions-with-Higher_002dOrder-Procedures" accesskey="u" rel="up">Formulating Abstractions with Higher-Order Procedures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Procedures-as-Returned-Values-1"></span><h4 class="subsection">1.3.4 Procedures as Returned Values</h4>

<ol>
<li> Average damp


<div class="float"><span id="average_002ddamp"></span>
<div class="example">
<pre class="example">(define (average-damp f)
  (lambda (x)
    (average x (f x))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.37: </strong>average-damp</p></div></div>
</li><li> Newton&rsquo;s method


<span id="index-first_002dclass"></span>

<p>If \( x \mapsto g(x) \) is a differentiable function, then a solution of the equation \( g(x)=0 \) is a fixed point of the function \( x \mapsto f(x) \) where
\[ f(x)=x-\frac{g(x)}{Dg(x)} \]
and \( Dg(x) \) is the derivative of \( g \) evaluated at \( x \).
</p>
<div class="float"><span id="newtons_002dmethod"></span>
<div class="example">
<pre class="example">(define (newton-transform g)
  (lambda (x)
    (- x (/ (g x)
            ((deriv g) x)))))

(define (newtons-method g guess)
  (fixed-point (newton-transform g)
               guess))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.38: </strong>newtons-method</p></div></div>
</li><li> Derivative


<p>If \( g \) is a function and \( dx \) is a small number, then the derivative \( Dg \) of \( g \) is the function whose value at \( x \) is given by
\[ Dg(x) = \frac{g(x+dx)-g(x)}{dx}. \]
</p>
<div class="float"><span id="deriv"></span>
<div class="example">
<pre class="example">(define dx 0.00001)
(define (deriv g)
  (lambda (x)
    (/ (- (g (+ x dx)) (g x))
       dx)))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.39: </strong>deriv</p></div></div>
</li><li> Abstractions and first-class procedures


<span id="index-fixed_002dpoint_002dof_002dtransform"></span>
<div class="float"><span id="fixed_002dpoint_002dof_002dtransform"></span>
<div class="example">
<pre class="example">(define (fixed-point-of-transform
         g transform guess)
  (fixed-point (transform g) guess))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.40: </strong>fixed-point-of-transform</p></div></div>
<div class="float"><span id="org7c09195"></span>
<div class="example">
<pre class="example">(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (/ x y))
   average-damp
   1.0))

(define (sqrt x)
  (fixed-point-of-transform
   (lambda (y) (- (square y) x))
   newton-transform
   1.0))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.41: </strong>Two ways to compute square roots as fixed points.</p></div></div>
</li><li> Exercise 1.40


<span id="Exercise-140-_00281_0029"></span><span id="index-1_002e40"></span>

<p>Define a procedure <code>cubic</code> that can be used together with the newtons-method procedure in expressions of the form
</p>
<div class="example">
<pre class="example">(newtons-method (cubic a b c) 1)
</pre></div>

<p>to approximate zeros of the cubic \( x^3+ax^2+bx+c. \)
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d40"></span>
<div class="example">
<pre class="example">(define (cubic a b c)
  (lambda (x)
    (+ (cube x)
       (* a (square x))
       (* b x)
       c)))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.42: </strong>exercise-1-40</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;fixed-point&gt;&gt;
&lt;&lt;deriv&gt;&gt;
&lt;&lt;newtons-method&gt;&gt;
&lt;&lt;exercise-1-40&gt;&gt;
(p (newtons-method (cubic 1 1 1) 1))
</pre></div>

<div class="example">
<pre class="example">

-0.9999999999997796
</pre></div>

</li><li> Exercise 1.41


<span id="Exercise-141-_00281_0029"></span><span id="index-1_002e41"></span>

<p>Define a procedure <code>double</code> that takes a procedure of one argument as argument and returns a procedure that applies the original procedure twice. For example, if inc is a procedure that adds 1 to its argument, then (double inc) should be a procedure that adds 2. What value is returned by
</p>
<div class="float"><span id="exercise_002d1_002d41_002dq"></span>
<div class="example">
<pre class="example">(((double (double double)) inc) 5)
</pre></div>

<div class="float-caption"><p><strong>Listing 1.43: </strong>exercise-1-41-q</p></div></div>
<p><strong>Solution</strong>
+CAPTION: exercise-1-41
</p><div class="example">
<pre class="example">(define (inc x) (+ x 1))
(define (double f)
  (lambda (x)
    (f (f x))))
</pre></div>

<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-41&gt;&gt;
(p &lt;&lt;exercise-1-41-q&gt;&gt;)
</pre></div>

<div class="example">
<pre class="example">

21
</pre></div>

</li><li> Exercise 1.42


<span id="Exercise-142-_00281_0029"></span><span id="index-1_002e42"></span>

<p>Let f and g be two one-argument functions. The composition f after g is defined to be the function x↦f(g(x)). Define a procedure compose that implements composition. For example, if inc is a procedure that adds 1 to its argument,
</p>
<div class="example">
<pre class="example">((compose square inc) 6)
49
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d42"></span>
<div class="example">
<pre class="example">(define (compose f g)
  (lambda (x) (f (g x))))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.44: </strong>exercise-1-42</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-42&gt;&gt;
(define (inc x) (+ x 1))
(p ((compose square inc) 6))
</pre></div>

<div class="example">
<pre class="example">

49
</pre></div>

</li><li> Exercise 1.43


<span id="Exercise-143-_00281_0029"></span><span id="index-1_002e43"></span>

<p>If f is a numerical function and n is a positive integer, then we can form the \( n^{th} \) repeated application of f, which is defined to be the function whose value at x is \( f(f(\cdots (f(x))\cdots)) \). For example, if f is the function \( x \mapsto x+1 \), then the \( n^{th}\) repeated application of f is the function \( x \mapsto x+n \). If f is the operation of squaring a number, then the \( n^{th}\) repeated application of f is the function that raises its argument to the \( 2^n \)-th power. Write a procedure that takes as inputs a procedure that computes f and a positive integer n and returns the procedure that computes the \( n^{th}\) repeated application of f. Your procedure should be able to be used as follows:
</p>
<div class="example">
<pre class="example">((repeated square 2) 5)
625
</pre></div>

<p>Hint: You may find it convenient to use compose from <a href="#Exercise-142-_00281_0029">Exercise 142 (1)</a>.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d43"></span>
<div class="example">
<pre class="example">(define (repeated f n)
  (if (&gt; n 1)
      (compose f (repeated f (- n 1)))
      f))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.45: </strong>exercise-1-43</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-42&gt;&gt;
&lt;&lt;exercise-1-43&gt;&gt;
(p ((repeated square 2) 5))
</pre></div>

<div class="example">
<pre class="example">

625
</pre></div>

</li><li> Exercise 1.44


<span id="Exercise-144-_00281_0029"></span><span id="index-1_002e44-smoothed-function"></span>

<p>The idea of smoothing a function is an important concept in signal processing. If f is a function and dx is some small number, then the smoothed version of f is the function whose value at a point x is the average of \( f(x-dx), f(x), \text{ and } f(x+dx). \) Write a procedure <code>smooth</code> that takes as input a procedure that computes f and returns a procedure that computes the smoothed f. It is sometimes valuable to repeatedly smooth a function (that is, smooth the smoothed function, and so on) to obtain the n-fold smoothed function. Show how to generate the n-fold smoothed function of any given function using smooth and repeated from <a href="#Exercise-143-_00281_0029">Exercise 143 (1)</a>.
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">(define (smooth f)
  (lambda (x)
    (average (f (- x dx))
             (f x)
             (f (+ x dx)))))

(define dx 0.00001)

(define (repeated-smooth f n)
  ((repeated smooth n) f))
</pre></div>

</li><li> Exercise 1.45


<span id="Exercise-145-_00281_0029"></span><span id="index-1_002e45-nth-root"></span>

<p>We saw in <a href="#Procedures-as-General-Methods">Procedures as General Methods</a> that attempting to compute square roots by naively finding a fixed point of \( y \mapsto x/y \) does not converge, and that this can be fixed by average damping. The same method works for finding cube roots as fixed points of the average-damped \( y \mapsto x/y^2 \). Unfortunately, the process does not work for fourth roots—a single average damp is not enough to make a fixed-point search for \( y \mapsto x/y^3 \) converge. On the other hand, if we average damp twice (i.e., use the average damp of the average damp of \( y \mapsto x/y^3 \)) the fixed-point search does converge. Do some experiments to determine how many average damps are required to compute \( n^{th} \) roots as a fixed-point search based upon repeated average damping of \( y \mapsto x/y^{n-1} \). Use this to implement a simple procedure for computing \( n^th \) roots using <code>fixed-point</code>, <code>average-damp</code>, and the repeated procedure of <a href="#Exercise-143-_00281_0029">Exercise 143 (1)</a>. Assume that any arithmetic operations you need are available as primitives.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d45"></span>
<div class="example">
<pre class="example">(define (root x n t)
  (fixed-point-of-transform (lambda (y) (/ x (expt y (- n 1))))
                            (repeated average-damp t)
                            1.0))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.46: </strong>exercise-1-45</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;fixed-point&gt;&gt;
&lt;&lt;fixed-point-of-transform&gt;&gt;
&lt;&lt;average-damp&gt;&gt;
&lt;&lt;exercise-1-43&gt;&gt;
&lt;&lt;exercise-1-45&gt;&gt;
(p (root 10 2 1))
(p (root 10 3 1))
(p (root 10 4 2))
(p (root 10 5 2))
(p (root 10 6 2))
(p (root 10 7 2))
;; (p (root 10 8 2)) infinite loop
(p (root 10 8 3))
;; (p (root 10 16 3)) infinite loop
(p (root 10 16 4))

</pre></div>

<div class="example">
<pre class="example">

3.162277660168379
2.154432882998236
1.7782794100444472
1.5848913895695755
1.4678013571259556
1.3894921800343574
1.333521432163324
1.154781984689469
</pre></div>



<table>
<thead><tr><th>nth root</th><th>t average damps needed</th></tr></thead>
<tr><td>2</td><td>1</td></tr>
<tr><td>3</td><td>1</td></tr>
<tr><td>4</td><td>2</td></tr>
<tr><td>8</td><td>3</td></tr>
<tr><td>16</td><td>4</td></tr>
</table>

<p>\[ t = \lfloor \log_2{n} \rfloor \]
</p>
<div class="float"><span id="exercise_002d1_002d45_002droot"></span>
<div class="example">
<pre class="example">(define (root x n)
  (let ((t (floor (/ (log n) (log 2)))))
    (fixed-point-of-transform (lambda (y) (/ x (expt y (- n 1))))
                              (repeated average-damp t)
                              1.0)))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.47: </strong>exercise-1-45-root</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;fixed-point&gt;&gt;
&lt;&lt;fixed-point-of-transform&gt;&gt;
&lt;&lt;average-damp&gt;&gt;
&lt;&lt;exercise-1-43&gt;&gt;
&lt;&lt;exercise-1-45-root&gt;&gt;
(p (root 10 2))
(p (root 10 5))
(p (root 10 10))
(p (root 10 20))
</pre></div>

<div class="example">
<pre class="example">

3.162277660168379
1.5848913895695755
1.2589247156514267
1.122017602303293
</pre></div>

</li><li> Exercise 1.46


<span id="Exercise-146-_00281_0029"></span><span id="index-1_002e46-iterative-improvement"></span>

<p>Several of the numerical methods described in this chapter are instances of an extremely general computational strategy known as iterative improvement. Iterative improvement says that, to compute something, we start with an initial guess for the answer, test if the guess is good enough, and otherwise improve the guess and continue the process using the improved guess as the new guess. Write a procedure iterative-improve that takes two procedures as arguments: a method for telling whether a guess is good enough and a method for improving a guess. Iterative-improve should return as its value a procedure that takes a guess as argument and keeps improving the guess until it is good enough. Rewrite the sqrt procedure of 1.1.7 and the fixed-point procedure of 1.3.3 in terms of iterative-improve.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d1_002d46"></span>
<div class="example">
<pre class="example">(define (iterative-improve good-enough? improve)
  (define (iter guess)
    (let ((next-guess (improve guess)))
      (if (good-enough? guess next-guess)
          next-guess
          (iter next-guess))))
  iter)
(define (ge? guess next-guess)
  (&lt; (abs (- guess next-guess)) 0.0001))
(define (sqrt x)
  ((iterative-improve ge?
                      (lambda (guess)
                        (average guess (/ x guess))))
   x))

(define (fixed-point f first-guess)
  ((iterative-improve ge?
                      (lambda (guess) (f guess)))
   first-guess))
</pre></div>

<div class="float-caption"><p><strong>Listing 1.48: </strong>exercise-1-46</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-1-46&gt;&gt;
(p (sqrt 4.0))
(p (fixed-point cos 1.0))
</pre></div>

<div class="example">
<pre class="example">

2.000000000000002
0.7390547907469174
</pre></div>
</li></ol>

<hr>
<span id="Building-Abstractions-with-Data"></span><div class="header">
<p>
Next: <a href="#Computing-with-Register-Machines" accesskey="n" rel="next">Computing with Register Machines</a>, Previous: <a href="#Building-Abstractions-with-Procedures" accesskey="p" rel="prev">Building Abstractions with Procedures</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Building-Abstractions-with-Data-1"></span><h2 class="chapter">2 Building Abstractions with Data</h2>

<span id="index-abstraction-barriers"></span>

<ul>
<li> Why do we want compound data in a programming language?

<p>For the same reasons that we want compound procedures: to elevate the conceptual level at which we can design our programs, to increase the modularity of our designs, and to enhance the expressive power of our language.
</p>
</li><li> What is the design methodology called data abstraction?

<p>The general technique of isolating the parts of a program that deal with how data objects are <strong>represented</strong> from the parts of a program that deal with how data objects are <strong>used</strong>.
</p>
</li><li> What is the key to forming compound data?

<p>The key is that a programming language should provide some kind of “glue” so that data objects can be combined to form more complex data objects.
</p>
<p>There are many possible kinds of glue. Indeed, we will discover how to form compound data using no special “data” operations at all, only procedures. This will further blur the distinction between “procedure” and “data”.
</p></li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Introduction-to-Data-Abstraction" accesskey="1">Introduction to Data Abstraction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Hierarchical-Data-and-the-Closure-Property" accesskey="2">Hierarchical Data and the Closure Property</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Introduction-to-Data-Abstraction"></span><div class="header">
<p>
Next: <a href="#Hierarchical-Data-and-the-Closure-Property" accesskey="n" rel="next">Hierarchical Data and the Closure Property</a>, Up: <a href="#Building-Abstractions-with-Data" accesskey="u" rel="up">Building Abstractions with Data</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Introduction-to-Data-Abstraction-1"></span><h3 class="section">2.1 Introduction to Data Abstraction</h3>

<span id="index-data-abstraction"></span>
<span id="index-selectors-and-constructors"></span>

<ul>
<li> What is data abstraction?

<p>Data abstraction is a methodology that enables us to isolate how a compound data object is used from the details of how it is constructed from more primitive data objects.
</p>
</li><li> What&rsquo;s the basic idea of data abstraction?

<p>The basic idea of data abstraction is to structure the programs that are to use compound data objects so that they operate on “abstract data.” That is, our programs should use data in such a way as to make no assumptions about the data that are not strictly necessary for performing the task at hand. At the same time, a “concrete” data representation is defined independent of the programs that use the data.
</p>
</li><li> What are selectors and constructors?

<p>The interface between these two parts of our system will be a set of procedures, called selectors and constructors, that implement the abstract data in terms of the concrete representation.
</p></li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Example-Arithmetic-Operations-for-Rational-Numbers" accesskey="1">Example Arithmetic Operations for Rational Numbers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Abstraction-Barriers" accesskey="2">Abstraction Barriers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#What-Is-Meant-by-Data_003f" accesskey="3">What Is Meant by Data?</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Extended-Exercise-Interval-Arithmetic" accesskey="4">Extended Exercise Interval Arithmetic</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Example-Arithmetic-Operations-for-Rational-Numbers"></span><div class="header">
<p>
Next: <a href="#Abstraction-Barriers" accesskey="n" rel="next">Abstraction Barriers</a>, Up: <a href="#Introduction-to-Data-Abstraction" accesskey="u" rel="up">Introduction to Data Abstraction</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Example-Arithmetic-Operations-for-Rational-Numbers-1"></span><h4 class="subsection">2.1.1 Example Arithmetic Operations for Rational Numbers</h4>

<span id="index-pair"></span>

<div class="float"><span id="rational_002doperations"></span>
<div class="example">
<pre class="example">(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))

(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))

(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))

(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.1: </strong>operations on rational numbers defined in terms of the selector and constructor procedures</p></div></div>
<div class="float"><span id="rational_002dnumbers"></span>
<div class="example">
<pre class="example">(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g)
          (/ d g))))
(define (numer x) (car x))
(define (denom x) (cdr x))

(define (print-rat x)
  (newline)
  (display (numer x))
  (display &quot;/&quot;)
  (display (denom x)))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.2: </strong>representing rational numbers</p></div></div>
<ol>
<li> Exercise 2.1


<span id="Exercise-21-_00281_0029"></span><span id="index-2_002e01-negative-rational"></span>

<p>Define a better version of <code>make-rat</code> that handles both positive and negative arguments. <code>Make-rat</code> should normalize the sign so that if the rational number is positive, both the numerator and denominator are positive, and if the rational number is negative, only the numerator is negative.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d1"></span>
<div class="example">
<pre class="example">;; gcd result is non-negative
(define (make-rat n d)
  (let ((signed-g ((if (&lt; d 0) - +)
                   (gcd n d))))
    (cons (/ n signed-g)
          (/ d signed-g))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.3: </strong>exercise-2-1</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;rational-numbers&gt;&gt;
&lt;&lt;rational-operations&gt;&gt;
&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-2-1&gt;&gt;
(print-rat (make-rat 2 -4))
</pre></div>

<div class="example">
<pre class="example">

-1/2
</pre></div>
</li></ol>

<hr>
<span id="Abstraction-Barriers"></span><div class="header">
<p>
Next: <a href="#What-Is-Meant-by-Data_003f" accesskey="n" rel="next">What Is Meant by Data?</a>, Previous: <a href="#Example-Arithmetic-Operations-for-Rational-Numbers" accesskey="p" rel="prev">Example Arithmetic Operations for Rational Numbers</a>, Up: <a href="#Introduction-to-Data-Abstraction" accesskey="u" rel="up">Introduction to Data Abstraction</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Abstraction-Barriers-1"></span><h4 class="subsection">2.1.2 Abstraction Barriers</h4>

<div class="float">
<img src="./images/2.1.2-rational-barrier.png" alt="./images/2.1.2-rational-barrier">

<div class="float-caption"><p><strong>Figure: </strong>Data-abstraction barriers in the rational-number package.</p></div></div>
<div class="float"><span id="org8a5a748"></span>
<div class="example">
<pre class="example">(define (make-rat n d)
  (cons n d))

(define (numer x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (car x) g)))

(define (denom x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (cdr x) g)))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.4: </strong>an alternate way to reduce rational numbers to lowest terms</p></div></div>
<ol>
<li> Exercise 2.2


<span id="Exercise-22-_00281_0029"></span><span id="index-2_002e02-segment-point"></span>

<p>Consider the problem of representing line segments in a plane. Each segment is represented as a pair of points: a starting point and an ending point. Define a constructor <code>make-segment</code> and selectors <code>start-segment</code> and <code>end-segment</code> that define the representation of segments in terms of points. Furthermore, a point can be represented as a pair of numbers: the x coordinate and the y coordinate. Accordingly, specify a constructor <code>make-point</code> and selectors <code>x-point</code> and <code>y-point</code> that define this representation. Finally, using your selectors and constructors, define a procedure <code>midpoint-segment</code> that takes a line segment as argument and returns its midpoint (the point whose coordinates are the average of the coordinates of the endpoints). To try your procedures, you’ll need a way to print points:
</p>
<div class="float"><span id="exercise_002d2_002d2_002dq"></span>
<div class="example">
<pre class="example">(define (print-point p)
  (newline)
  (display &quot;(&quot;)
  (display (x-point p))
  (display &quot;,&quot;)
  (display (y-point p))
  (display &quot;)&quot;))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.5: </strong>exercise-2-2-q</p></div></div>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d2"></span>
<div class="example">
<pre class="example">;;; point
(define (make-point x y) (cons x y))
(define (x-point p) (car p))
(define (y-point p) (cdr p))
(define (mid-point a b)
  (make-point (average (x-point a) (x-point b))
              (average (y-point a) (y-point b))))

;;; segment
(define (make-segment start-point end-point)
  (cons start-point end-point))
(define (start-segment seg) (car seg))
(define (end-segment seg) (cdr seg))
(define (midpoint-segment seg)
  (mid-point (start-segment seg)
             (end-segment seg)))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.6: </strong>exercise-2-2</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-2-2-q&gt;&gt;
&lt;&lt;exercise-2-2&gt;&gt;
(define a (make-point 0 2))
(define b (make-point 2 0))
(define s (make-segment a b))
(print-point (midpoint-segment s))
</pre></div>

<div class="example">
<pre class="example">

(1,1)
</pre></div>

</li><li> Exercise 2.3


<span id="Exercise-23-_00281_0029"></span><span id="index-2_002e03-rectangle"></span>

<p>Implement a representation for rectangles in a plane. (Hint: You may want to make use of <a href="#Exercise-22-_00281_0029">Exercise 22 (1)</a>.) In terms of your constructors and selectors, create procedures that compute the perimeter and the area of a given rectangle. Now implement a different representation for rectangles. Can you design your system with suitable abstraction barriers, so that the same perimeter and area procedures will work using either representation?
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d3"></span>
<div class="example">
<pre class="example">(define (distance-points p1 p2)
  (sqrt (+ (square (- (x-point p1)
                      (x-point p2)))
           (square (- (y-point p1)
                      (y-point p2))))))

(define (length-segment seg)
  (distance-points (start-segment seg)
                   (end-segment seg)))

(define (min-segments seg1 seg2)
  (let ((l1 (length-segment seg1))
        (l2 (length-segment seg2)))
    (if (&lt; l2 l1) seg2 seg1)))

(define (max-segments seg1 seg2)
  (let ((l1 (length-segment seg1))
        (l2 (length-segment seg2)))
    (if (&gt; l2 l1) seg2 seg1)))

;;
;;      +--------+
;; seg1 |        |
;;      |        |
;;      +--------+
;;         seg2
;;
;; defined by two intersecting sides
;;
(define (make-rect seg1 seg2)
  (cons (max-segments seg1 seg2)
        (min-segments seg1 seg2)))
(define (length-rect rect) (car rect))
(define (breadth-rect rect) (cdr rect))

;;         seg1
;;      +--------+
;;      |        |
;;      |        |
;;      +--------+
;;         seg2
;;
;; defined by two parallel sides
;;
(define (make-rect-p seg1 seg2)
  (let ((s1start (start-segment seg1))
        (s2start (start-segment seg2))
        (s2end (end-segment seg2)))
    (let ((seg3 (make-segment s1start s2start))
          (seg4 (make-segment s1start s2end)))
      (make-rect seg1 (min-segments seg3 seg4)))))

(define (perimeter-rect r)
  (* 2 (+ (length-segment (length-rect r))
          (length-segment (breadth-rect r)))))

(define (area-rect r)
  (* (length-segment (length-rect r))
     (length-segment (breadth-rect r))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.7: </strong>exercise-2-3</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-2-2-q&gt;&gt;
&lt;&lt;exercise-2-2&gt;&gt;
&lt;&lt;exercise-2-3&gt;&gt;
;;               s3
;; p4 (0,3)  +--------+ p3 (5,3)
;;        s1 |        |
;;           |        |
;; p1 (0,0)  +--------+ p2 (5,0)
;;               s2
(define p1 (make-point 0 0))
(define p2 (make-point 5 0))
(define p3 (make-point 5 3))
(define p4 (make-point 0 3))
(define s1 (make-segment  p1 p4))
(define s2 (make-segment  p1 p2))
(define s3 (make-segment  p4 p3))
(define r1 (make-rect s1 s2))
(define r2 (make-rect-p s2 s3))
(p (perimeter-rect r1))
(p (area-rect r1))
(p (perimeter-rect r2))
(p (area-rect r2))
</pre></div>

<div class="example">
<pre class="example">

16
15
16
15
</pre></div>
</li></ol>

<hr>
<span id="What-Is-Meant-by-Data_003f"></span><div class="header">
<p>
Next: <a href="#Extended-Exercise-Interval-Arithmetic" accesskey="n" rel="next">Extended Exercise Interval Arithmetic</a>, Previous: <a href="#Abstraction-Barriers" accesskey="p" rel="prev">Abstraction Barriers</a>, Up: <a href="#Introduction-to-Data-Abstraction" accesskey="u" rel="up">Introduction to Data Abstraction</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="What-Is-Meant-by-Data_003f-1"></span><h4 class="subsection">2.1.3 What Is Meant by Data?</h4>

<span id="index-message-passing"></span>

<ul>
<li> what is meant by data?

<p>we can think of data as defined by
</p><ul>
<li> some collection of selectors and constructors, together with
</li><li> specified conditions that these procedures must fulfill in order to be a valid representation.
</li></ul>
<p><code>Make-rat</code>, <code>numer</code>, and <code>denom</code> must satisfy the condition that, for any integer n and any non-zero integer d, if x is <code>(make-rat n d)</code>, then \[ \frac{\text{(numer x)}}{\text{(denom x)}}=\frac{\text{n}}{\text{d}}. \]
The operations satisfy the condition that, for any objects x and y, if z is (cons x y) then (car z) is x and (cdr z) is y.
</p></li></ul>


<div class="float"><span id="org7f1138a"></span>
<div class="example">
<pre class="example">(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else
           (error &quot;Argument not 0 or 1:
                   CONS&quot; m))))
  dispatch)

(define (car z) (z 0))
(define (cdr z) (z 1))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.8: </strong>implement cons, car, and cdr without using any data structures at all but only using procedures</p></div></div>
<ol>
<li> Exercise 2.4


<span id="Exercise-24-_00281_0029"></span><span id="index-2_002e04-procedural-representation-of-pairs"></span>

<p>Here is an alternative procedural representation of pairs. For this representation, verify that <code>(car (cons x y))</code> yields x for any objects x and y.
</p>
<div class="float"><span id="exercise_002d2_002d4_002dq"></span>
<div class="example">
<pre class="example">(define (cons x y)
  (lambda (m) (m x y)))

(define (car z)
  (z (lambda (p q) p)))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.9: </strong>exercise-2-4-q</p></div></div>
<p>What is the corresponding definition of <code>cdr</code>? (Hint: To verify that this works, make use of the substitution model of <a href="#The-Substitution-Model-for-Procedure-Application">The Substitution Model for Procedure Application</a>.)
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d4"></span>
<div class="example">
<pre class="example">;;(car (cons x y))
;;(car (lambda (p q) p))
;;((lambda (m) (m x y)) (lambda (p q) p))
;;((lambda (p q) p) x y)
;;x

(define (cdr z)
  (z (lambda (p q) q)))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.10: </strong>exercise-2-4</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-2-4-q&gt;&gt;
&lt;&lt;exercise-2-4&gt;&gt;
(define x (cons 1 2))
(p x)
(p (car x))
(p (cdr x))
</pre></div>

<div class="example">
<pre class="example">

#&lt;procedure 105f775a0 at &lt;unknown port&gt;:16:2 (m)&gt;
1
2
</pre></div>

</li><li> Exercise 2.5


<span id="Exercise-25-_00281_0029"></span><span id="index-2_002e05-numbers-represent-pairs"></span>

<p>Show that we can represent pairs of nonnegative integers using only numbers and arithmetic operations if we represent the pair a and b as the integer that is the product \( 2^a3^b \). Give the corresponding definitions of the procedures cons, car, and cdr.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d5"></span>
<div class="example">
<pre class="example">(define (cons a b)
  (* (expt 2 a)
     (expt 3 b)))

(define (largest-divisible-exponent n base)
  (define (iter i)
    (if (= (remainder n (expt base i)) 0)
        (iter (+ i 1))
        (- i 1)))
  (iter 1))

(define (car n) (largest-divisible-exponent n 2))
(define (cdr n) (largest-divisible-exponent n 3))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.11: </strong>exercise-2-5</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-2-5&gt;&gt;
(define a (cons 2 2))
(p a)
(p (car a))
(p (cdr a))
</pre></div>

<div class="example">
<pre class="example">

36
2
2
</pre></div>

</li><li> Exercise 2.6


<span id="Exercise-26-_00281_0029"></span><span id="index-2_002e06-Church-numerals"></span>

<p>In case representing pairs as procedures wasn’t mind-boggling enough, consider that, in a language that can manipulate procedures, we can get by without numbers (at least insofar as nonnegative integers are concerned) by implementing 0 and the operation of adding 1 as
</p>
<div class="float"><span id="exercise_002d2_002d6_002dq"></span>
<div class="example">
<pre class="example">(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
  (lambda (f) (lambda (x) (f ((n f) x)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.12: </strong>exercise-2-6-q</p></div></div>
<p>This representation is known as <em>Church numerals</em>, after its inventor, Alonzo Church, the logician who invented the λ-calculus.
</p>
<p>Define <code>one</code> and <code>two</code> directly (not in terms of <code>zero</code> and <code>add-1</code>). (Hint: Use substitution to evaluate <code>(add-1 zero)</code>). Give a direct definition of the addition procedure <code>+</code> (not in terms of repeated application of <code>add-1</code>).
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d6"></span>
<div class="example">
<pre class="example">;; (add-1 zero)
;; (lambda (f) (lambda (x) (f ((zero f) x))))
;; (lambda (f) (lambda (x) (f x)))
(define one (lambda (f) (lambda (x) (f x))))

;; (add-1 one)
;; (lambda (f) (lambda (x) (f ((one f) x))))
;; (lambda (f) (lambda (x) (f (f x))))
(define two (lambda (f) (lambda (x) (f (f x)))))

(define (+ a b)
  (lambda (f) (lambda (x) ((b f) ((a f) x)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.13: </strong>exercise-2-6</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-2-6-q&gt;&gt;
&lt;&lt;exercise-2-6&gt;&gt;
(p &quot;--zero--&quot;)
((zero p) 'hello)
(p &quot;--one--&quot;)
((one p) 'hello)
(p &quot;--two--&quot;)
((two p) 'hello)
(p &quot;--three--&quot;)
(((+ one two) p) 'hello)
</pre></div>

<div class="example">
<pre class="example">

--zero--
--one--
hello
--two--
hello
hello
--three--
hello
hello
hello
</pre></div>
</li></ol>

<hr>
<span id="Extended-Exercise-Interval-Arithmetic"></span><div class="header">
<p>
Previous: <a href="#What-Is-Meant-by-Data_003f" accesskey="p" rel="prev">What Is Meant by Data?</a>, Up: <a href="#Introduction-to-Data-Abstraction" accesskey="u" rel="up">Introduction to Data Abstraction</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Extended-Exercise-Interval-Arithmetic-1"></span><h4 class="subsection">2.1.4 Extended Exercise Interval Arithmetic</h4>

<ul>
<li> What are the benefits of manipulating inexact quantities with known precision?

<p>When computations are done with such approximate quantities the results will be numbers of known precision.
</p></li></ul>
<div class="example">
<pre class="example">(define (add-interval x y)
  (make-interval (+ (lower-bound x)
                    (lower-bound y))
                 (+ (upper-bound x)
                    (upper-bound y))))
(define (mul-interval x y)
  (let ((p1 (* (lower-bound x)
               (lower-bound y)))
        (p2 (* (lower-bound x)
               (upper-bound y)))
        (p3 (* (upper-bound x)
               (lower-bound y)))
        (p4 (* (upper-bound x)
               (upper-bound y))))
    (make-interval (min p1 p2 p3 p4)
                   (max p1 p2 p3 p4))))
(define (div-interval x y)
  (mul-interval x
                (make-interval
                 (/ 1.0 (upper-bound y))
                 (/ 1.0 (lower-bound y)))))
</pre></div>

<ol>
<li> Exercise 2.7


<span id="Exercise-27-_00281_0029"></span><span id="index-2_002e07-selectors"></span>

<p>Alyssa’s program is incomplete because she has not specified the implementation of the interval abstraction. Here is a definition of the interval constructor:
</p><div class="example">
<pre class="example">(define (make-interval a b) (cons a b))
</pre></div>
<p>Define selectors <code>upper-bound</code> and <code>lower-bound</code> to complete the implementation.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d7"></span>
<div class="example">
<pre class="example">(define (make-interval a b) (cons a b))
(define (upper-bound n) (max (car n) (cdr n)))
(define (lower-bound n) (min (car n) (cdr n)))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.14: </strong>exercise-2-7</p></div></div>
</li><li> Exercise 2.8


<span id="Exercise-28-_00281_0029"></span><span id="index-2_002e08-sub"></span>

<p>Using reasoning analogous to Alyssa’s, describe how the difference of two intervals may be computed. Define a corresponding subtraction procedure, called <code>sub-interval</code>.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d8"></span>
<div class="example">
<pre class="example">(define (sub-interval x y)
  (let ((d1 (- (lower-bound x)
               (lower-bound y)))
        (d2 (- (lower-bound x)
               (upper-bound y)))
        (d3 (- (upper-bound x)
               (lower-bound y)))
        (d4 (- (upper-bound x)
               (upper-bound y))))
    (make-interval (min d1 d2 d3 d4)
                   (max d1 d2 d3 d4))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.15: </strong>exercise-2-8</p></div></div>
</li><li> Exercise 2.9


<span id="Exercise-29-_00281_0029"></span><span id="index-2_002e09-width"></span>

<p>The <em>width</em> of an interval is half of the difference between its upper and lower bounds. The width is a measure of the uncertainty of the number specified by the interval. For some arithmetic operations the width of the result of combining two intervals is a function only of the widths of the argument intervals, whereas for others the width of the combination is not a function of the widths of the argument intervals. Show that the width of the sum (or difference) of two intervals is a function only of the widths of the intervals being added (or subtracted). Give examples to show that this is not true for multiplication or division.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d9"></span>
<div class="example">
<pre class="example">(define (width x)
  (/ (- (upper-bound x)
        (lower-bound x))
     2.0))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.16: </strong>exercise-2-9</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;interval&gt;&gt;
&lt;&lt;exercise-2-7&gt;&gt;
&lt;&lt;exercise-2-8&gt;&gt;
&lt;&lt;exercise-2-9&gt;&gt;
(define a (make-interval 1 5))
(define b (make-interval 2 9))
(display &quot;width of a: &quot;)
(display (width a))
(p &quot;width of b: &quot;)
(display (width b))
(p &quot;width of a+b: &quot;)
(display (width (add-interval a b)))
(p &quot;width of a-b: &quot;)
(display (width (sub-interval a b)))
(p &quot;width of a*b: &quot;)
(display (width (mul-interval a b)))
(p &quot;width of a/b: &quot;)
(display (width (div-interval a b)))
</pre></div>

<div class="example">
<pre class="example">width of a: 2.0
width of b: 3.5
width of a+b: 5.5
width of a-b: 5.5
width of a*b: 21.5
width of a/b: 1.1944444444444444
</pre></div>


<p>We can draw conclusions about addition and subtraction
\[ \operatorname{width}(a \pm b) = \operatorname{width}(a) + \operatorname{width}(b). \]
</p>
</li><li> Exercise 2.10


<span id="Exercise-210-_00281_0029"></span><span id="index-2_002e10-div-denominator-check"></span>

<p>Ben Bitdiddle, an expert systems programmer, looks over Alyssa’s shoulder and comments that it is not clear what it means to divide by an interval that spans zero. Modify Alyssa’s code to check for this condition and to signal an error if it occurs.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d10"></span>
<div class="example">
<pre class="example">(define (div-interval x y)
  (if (&lt;= (* (upper-bound y)
             (lower-bound y))
          0)
      (error &quot;divide by an interval that spans zero&quot;)
      (mul-interval x
                    (make-interval
                     (/ 1.0 (upper-bound y))
                     (/ 1.0 (lower-bound y))))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.17: </strong>exercise-2-10</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;interval&gt;&gt;
&lt;&lt;exercise-2-7&gt;&gt;
&lt;&lt;exercise-2-8&gt;&gt;
&lt;&lt;exercise-2-10&gt;&gt;
(div-interval (make-interval 2 9)
              (make-interval -1 2))
</pre></div>

<div class="example">
<pre class="example">ice-9/boot-9.scm:1669:16: In procedure raise-exception:
divide by an interval that spans zero

Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
scheme@(guile-user) [1]&gt;
</pre></div>

</li><li> Exercise 2.11


<span id="Exercise-211-_00281_0029"></span><span id="index-2_002e11-center-width"></span>

<p>In passing, Ben also cryptically comments: “By testing the signs of the endpoints of the intervals, it is possible to break mul-interval into nine cases, only one of which requires more than two multiplications.” Rewrite this procedure using Ben’s suggestion.
</p>
<p>After debugging her program, Alyssa shows it to a potential user, who complains that her program solves the wrong problem. He wants a program that can deal with numbers represented as a center value and an additive tolerance; for example, he wants to work with intervals such as 3.5 ± 0.15 rather than [3.35, 3.65]. Alyssa returns to her desk and fixes this problem by supplying an alternate constructor and alternate selectors:
</p>
<div class="float"><span id="exercise_002d2_002d11_002dq"></span>
<div class="example">
<pre class="example">(define (make-center-width c w)
  (make-interval (- c w) (+ c w)))

(define (center i)
  (/ (+ (lower-bound i)
        (upper-bound i))
     2.0))

(define (width i)
  (/ (- (upper-bound i)
        (lower-bound i))
     2.0))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.18: </strong>exercise-2-11-q</p></div></div>
<p>Unfortunately, most of Alyssa’s users are engineers. Real engineering situations usually involve measurements with only a small uncertainty, measured as the ratio of the width of the interval to the midpoint of the interval. Engineers usually specify percentage tolerances on the parameters of devices, as in the resistor specifications given earlier.
</p>
<p><strong>Solution</strong>
</p>
<p>The interval can be divided into 3 cases according to the symbol combination of two endpoints, nn np pp, then the two endpoints are multiplied by 9 cases.
</p>
<p>Giving two intervals of \( [a,b],[p,q]: \)
</p>
<p>\begin{array}{ccc}
       nn nn &amp;\rightarrow &amp;[bq, ap] \\
       nn np &amp;\rightarrow &amp;[aq, ap] \\
       nn pp &amp;\rightarrow &amp;[aq, bp] \\
       np nn &amp;\rightarrow &amp;[bp, ap] \\
       np np &amp;\rightarrow &amp;[ap, bq] \\
       np pp &amp;\rightarrow &amp;[aq, bq] \\
       pp nn &amp;\rightarrow &amp;[bp, aq] \\
       pp np &amp;\rightarrow &amp;[bp, bq] \\
       pp pp &amp;\rightarrow &amp;[ap, bq] \\
     \end{array}
</p>
<div class="float"><span id="exercise_002d2_002d11"></span>
<div class="example">
<pre class="example">(define (ltz? a b)
  (and (&lt; a 0) (&lt;= b 0)))

(define (spz? a b)
  (and (&lt; a 0) (&gt; b 0)))

(define (gtz? a b)
  (and (&gt;= a 0) (&gt; b 0)))

(define (mul-interval x y)
  (let ((a (lower-bound x))
        (b (upper-bound x))
        (p (lower-bound y))
        (q (upper-bound y)))
    (cond ((and (ltz? a b) (ltz? p q))
           (make-interval (* b q) (* a p)))
          ((and (ltz? a b) (spz? p q))
           (make-interval (* a q) (* a p)))
          ((and (ltz? a b) (gtz? p q))
           (make-interval (* a q) (* b p)))
          ((and (spz? a b) (ltz? p q))
           (make-interval (* b p) (* a p)))
          ((and (spz? a b) (spz? p q))
           (make-interval (* a p) (* b q)))
          ((and (spz? a b) (gtz? p q))
           (make-interval (* a q) (* b q)))
          ((and (gtz? a b) (ltz? p q))
           (make-interval (* b p) (* a q)))
          ((and (gtz? a b) (spz? p q))
           (make-interval (* b p) (* b q)))
          ((and (gtz? a b) (gtz? p q))
           (make-interval (* a p) (* b q))))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.19: </strong>exercise-2-11</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;interval&gt;&gt;
&lt;&lt;exercise-2-7&gt;&gt;
&lt;&lt;exercise-2-8&gt;&gt;
&lt;&lt;exercise-2-11&gt;&gt;
(p (mul-interval (make-interval -2 -1)
                 (make-interval -5 3)))
</pre></div>

<div class="example">
<pre class="example">

(-6 . 10)
</pre></div>

</li><li> Exercise 2.12


<span id="Exercise-212-_00281_0029"></span><span id="index-2_002e12-center-percent"></span>

<p>Define a constructor <code>make-center-percent</code> that takes a center and a percentage tolerance and produces the desired interval. You must also define a selector <code>percent</code> that produces the percentage tolerance for a given interval. The <code>center</code> selector is the same as the one shown above.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d12"></span>
<div class="example">
<pre class="example">(define (make-center-percent c p)
  (let ((w (* c p)))
    (make-center-width c w)))

(define (percent i)
  (/ (width i) (center i)))

(define (print x)
  (newline)
  (display &quot;[&quot;)
  (display (lower-bound x))
  (display &quot;, &quot;)
  (display (upper-bound x))
  (display &quot;]&quot;))
(define (print-cp x)
  (newline)
  (display (center x))
  (display &quot;±&quot;)
  (display (* 100 (percent x)))
  (display &quot;%&quot;))
(define (print-cw x)
  (newline)
  (display (center x))
  (display &quot;±&quot;)
  (display (width x)))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.20: </strong>exercise-2-12</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;interval&gt;&gt;
&lt;&lt;exercise-2-7&gt;&gt;
&lt;&lt;exercise-2-8&gt;&gt;
&lt;&lt;exercise-2-11-q&gt;&gt;
&lt;&lt;exercise-2-12&gt;&gt;
(define x (make-center-percent 5 0.1))
(p x)
(print x)
(print-cp x)
(print-cw x)
</pre></div>

<div class="example">
<pre class="example">

(4.5 . 5.5)
[4.5, 5.5]
5.0±10.0%
5.0±0.5
</pre></div>

</li><li> Exercise 2.13


<span id="Exercise-213-_00281_0029"></span><span id="index-2_002e13"></span>

<p>Show that under the assumption of small percentage tolerances there is a simple formula for the approximate percentage tolerance of the product of two intervals in terms of the tolerances of the factors. You may simplify the problem by assuming that all numbers are positive.
</p>
<p>After considerable work, Alyssa P. Hacker delivers her finished system. Several years later, after she has forgotten all about it, she gets a frenzied call from an irate user, Lem E. Tweakit. It seems that Lem has noticed that the formula for parallel resistors can be written in two algebraically equivalent ways:
\[ \frac{R_1R_2}{R_1+R_2} \]
and
\[ \frac{1}{1/R_1+1/R_2}. \]
He has written the following two programs, each of which computes the parallel-resistors formula differently:
</p>
<div class="float"><span id="exercise_002d2_002d13_002dq"></span>
<div class="example">
<pre class="example">(define (par1 r1 r2)
  (div-interval
   (mul-interval r1 r2)
   (add-interval r1 r2)))

(define (par2 r1 r2)
  (let ((one (make-interval 1 1)))
    (div-interval
     one
     (add-interval
      (div-interval one r1)
      (div-interval one r2)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.21: </strong>exercise-2-13-q</p></div></div>
<p>Lem complains that Alyssa’s program gives different answers for the two ways of computing. This is a serious complaint.
</p>
<p><strong>Solution</strong>
</p>
<p>\begin{array}{l}
       [c_1(1-p_1),c_1(1+p_1)]\centerdot [c_2(1-p_2),c_2(1+p_2)] \\
       =[c_1c_2-c_1c_2p_1-c_1c_2p_2+c_1c_2p_1p_2,\dotsc] \\
       =[c_1c_2(1-p_1-p_2+p_1p_2),c_1c_2(1+p_1+p_2+p_1p_2)] \\
       \overset{\text{误差很小}}{\approx} [c_1c_2(1-(p_1+p_2)),c_1c_2(1+p_1+p_2)]
     \end{array}
</p>
</li><li> Exercise 2.14


<span id="Exercise-214-_00281_0029"></span><span id="index-2_002e14"></span>

<p>Demonstrate that Lem is right. Investigate the behavior of the system on a variety of arithmetic expressions. Make some intervals A and B, and use them in computing the expressions A/A and A/B. You will get the most insight by using intervals whose width is a small percentage of the center value. Examine the results of the computation in center-percent form (see <a href="#Exercise-212-_00281_0029">Exercise 212 (1)</a>).
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;interval&gt;&gt;
&lt;&lt;exercise-2-7&gt;&gt;
&lt;&lt;exercise-2-8&gt;&gt;
&lt;&lt;exercise-2-11-q&gt;&gt;
&lt;&lt;exercise-2-12&gt;&gt;
&lt;&lt;exercise-2-13-q&gt;&gt;

(define x (make-center-percent 10 0.1))
(print-cp (par1 x x))
(print-cp (par2 x x))
(p &quot;----&quot;)

(define A (make-center-percent 100 0.01))
(define B (make-center-percent 200 0.02))
(define C (make-center-percent 4 0.5))
(define D (make-center-percent 8 0.2))

(print-cp (div-interval A A))
(print-cp (div-interval A B))
(print-cp (div-interval C C))
(print-cp (div-interval C D))
</pre></div>

<div class="example">
<pre class="example">

5.2020202020202015±29.22330097087378%
5.0±10.0%
----
1.0002000200020003±1.9998000199980077%
0.5003001200480192±2.9994001199760016%
1.6666666666666667±80.0%
0.5729166666666666±63.63636363636363%
</pre></div>


<p>So Lem is right. An interval divided by itself will not produce [1,1], instead it will introduce uncertainty.
</p>
</li><li> Exercise 2.15


<span id="Exercise-215-_00281_0029"></span><span id="index-2_002e15"></span>

<p>Eva Lu Ator, another user, has also noticed the different intervals computed by different but algebraically equivalent expressions. She says that a formula to compute with intervals using Alyssa’s system will produce tighter error bounds if it can be written in such a form that no variable that represents an uncertain number is repeated. Thus, she says, par2 is a “better” program for parallel resistances than par1. Is she right? Why?
</p>
<p><strong>Solution</strong>
</p>
<p>Eva is right since the error isn&rsquo;t reintroduced into the result in par2 as it is in par1.
</p>
</li><li> Exercise 2.16


<span id="Exercise-216-_00281_0029"></span><span id="index-2_002e16"></span>

<p>Explain, in general, why equivalent algebraic expressions may lead to different answers. Can you devise an interval-arithmetic package that does not have this shortcoming, or is this task impossible? (Warning: This problem is very difficult.)
</p>
<p><strong>Solution</strong>
</p>
<p>Because part of algebraic laws doesn&rsquo;t work in interval arithmetic such as distributive law, self-division, and square.
</p></li></ol>

<hr>
<span id="Hierarchical-Data-and-the-Closure-Property"></span><div class="header">
<p>
Previous: <a href="#Introduction-to-Data-Abstraction" accesskey="p" rel="prev">Introduction to Data Abstraction</a>, Up: <a href="#Building-Abstractions-with-Data" accesskey="u" rel="up">Building Abstractions with Data</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Hierarchical-Data-and-the-Closure-Property-1"></span><h3 class="section">2.2 Hierarchical Data and the Closure Property</h3>

<span id="index-closure-property"></span>

<ul>
<li> What is closure property?

<p>An operation for combining data objects satisfies the closure property if the results of combining things with that operation can themselves be combined using the same operation.
</p>
<p>Another explanation: a closure is an implementation technique for representing procedures with free variables.
</p>
</li><li> Why is closure property important?

<p>Closure is the key to power in any means of combination because it permits us to create hierarchical structures—structures made up of parts, which themselves are made up of parts, and so on.
</p></li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Representing-Sequences" accesskey="1">Representing Sequences</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Hierarchical-Structures" accesskey="2">Hierarchical Structures</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Sequences-as-Conventional-Interfaces" accesskey="3">Sequences as Conventional Interfaces</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Example-A-Picture-Language" accesskey="4">Example A Picture Language</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Representing-Sequences"></span><div class="header">
<p>
Next: <a href="#Hierarchical-Structures" accesskey="n" rel="next">Hierarchical Structures</a>, Up: <a href="#Hierarchical-Data-and-the-Closure-Property" accesskey="u" rel="up">Hierarchical Data and the Closure Property</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Representing-Sequences-1"></span><h4 class="subsection">2.2.1 Representing Sequences</h4>

<div class="float"><span id="list"></span>
<div class="example">
<pre class="example">(define (list-ref items n)
  (if (= n 0)
      (car items)
      (list-ref (cdr items)
                (- n 1))))

(define (length items)
  (if (null? items)
      0
      (+ 1 (length (cdr items)))))

(define (append list1 list2)
  (if (null? list1)
      list2
      (cons (car list1)
            (append (cdr list1) list2))))

(define (map proc items)
  (if (null? items)
      nil
      (cons (proc (car items))
            (map proc (cdr items)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.22: </strong>list</p></div></div>
<ol>
<li> Exercise 2.17


<span id="Exercise-217-_00281_0029"></span><span id="index-2_002e17-last_002dpair"></span>

<p>Define a procedure <code>last-pair</code> that returns the list that contains only the last element of a given (nonempty) list:
</p>
<div class="example">
<pre class="example">(last-pair (list 23 72 149 34))
(34)
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d17"></span>
<div class="example">
<pre class="example">(define (last-pair items)
  (if (null? (cdr items))
      items
      (last-pair (cdr items))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.23: </strong>exercise-2-17</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;exercise-2-17&gt;&gt;
(p (last-pair (list 23 72 149 34)))
</pre></div>

<div class="example">
<pre class="example">

(34)
</pre></div>

</li><li> Exercise 2.18


<span id="Exercise-218-_00281_0029"></span><span id="index-2_002e18-reverse"></span>

<p>Define a procedure <code>reverse</code> that takes a list as argument and returns a list of the same elements in reverse order:
</p>
<div class="example">
<pre class="example">(reverse (list 1 4 9 16 25))
(25 16 9 4 1)
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d18"></span>
<div class="example">
<pre class="example">(define (reverse items)
  (define (iter items result)
    (if (null? items)
        result
        (iter (cdr items)
              (cons (car items) result))))
  (iter items nil))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.24: </strong>exercise-2-18</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;exercise-2-18&gt;&gt;
(p (reverse (list 1 4 9 16 25)))
</pre></div>

<div class="example">
<pre class="example">

(25 16 9 4 1)
</pre></div>

</li><li> Exercise 2.19


<span id="Exercise-219-_00281_0029"></span><span id="index-2_002e19-change_002dcounting"></span>

<p>Consider the change-counting program of <a href="#Tree-Recursion">Tree Recursion</a>. It would be nice to be able to easily change the currency used by the program, so that we could compute the number of ways to change a British pound, for example. As the program is written, the knowledge of the currency is distributed partly into the procedure <code>first-denomination</code> and partly into the procedure <code>count-change</code> (which knows that there are five kinds of U.S. coins). It would be nicer to be able to supply a list of coins to be used for making change.
</p>
<p>We want to rewrite the procedure <code>cc</code> so that its second argument is a list of the values of the coins to use rather than an integer specifying which coins to use. We could then have lists that defined each kind of currency:
</p>
<div class="float"><span id="exercise_002d2_002d19_002dq1"></span>
<div class="example">
<pre class="example">(define us-coins
  (list 50 25 10 5 1))

(define uk-coins
  (list 100 50 20 10 5 2 1 0.5))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.25: </strong>exercise-2-19-q1</p></div></div>
<p>We could then call <code>cc</code> as follows:
</p>
<div class="example">
<pre class="example">(cc 100 us-coins)
292
</pre></div>

<p>To do this will require changing the program <code>cc</code> somewhat. It will still have the same form, but it will access its second argument differently, as follows:
</p>
<div class="float"><span id="exercise_002d2_002d19_002dq2"></span>
<div class="example">
<pre class="example">(define (cc amount coin-values)
  (cond ((= amount 0)
         1)
        ((or (&lt; amount 0)
             (no-more? coin-values))
         0)
        (else
         (+ (cc amount
                (except-first-denomination coin-values))
            (cc (- amount (first-denomination coin-values))
                coin-values)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.26: </strong>exercise-2-19-q2</p></div></div>
<p>Define the procedures <code>first-denomination</code>, <code>except-first-denomination</code> and <code>no-more?</code> in terms of primitive operations on list structures. Does the order of the list coin-values affect the answer produced by <code>cc</code>? Why or why not?
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d19"></span>
<div class="example">
<pre class="example">(define first-denomination car)
(define except-first-denomination cdr)
(define no-more? null?)
</pre></div>

<div class="float-caption"><p><strong>Listing 2.27: </strong>exercise-2-19</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;count-change&gt;&gt;
&lt;&lt;exercise-2-19-q1&gt;&gt;
&lt;&lt;exercise-2-19-q2&gt;&gt;
&lt;&lt;exercise-2-19&gt;&gt;
(p (cc 100 us-coins))
</pre></div>

<div class="example">
<pre class="example">

292
</pre></div>

</li><li> Exercise 2.20


<span id="Exercise-220-_00281_0029"></span><span id="index-2_002e20-arbitrary-numbers-of-arguments"></span>

<p>The procedures <code>+</code>, <code>*</code>, and <code>list</code> take arbitrary numbers of arguments. One way to define such procedures is to use <code>define</code> with <em>dotted-tail</em> notation. In a procedure definition, a parameter list that has a dot before the last parameter name indicates that, when the procedure is called, the initial parameters (if any) will have as values the initial arguments, as usual, but the final parameter’s value will be a list of any remaining arguments. For instance, given the definition
</p>
<div class="example">
<pre class="example">(define (f x y . z) ⟨body⟩)
</pre></div>

<p>the procedure <code>f</code> can be called with two or more arguments. If we evaluate
</p>
<div class="example">
<pre class="example">(f 1 2 3 4 5 6)
</pre></div>

<p>then in the body of <code>f</code>, <code>x</code> will be 1, <code>y</code> will be 2, and <code>z</code> will be the list <code>(3 4 5 6)</code>. Given the definition
</p>
<div class="example">
<pre class="example">(define (g . w) ⟨body⟩)
</pre></div>

<p>the procedure g can be called with zero or more arguments. If we evaluate
</p>
<div class="example">
<pre class="example">(g 1 2 3 4 5 6)
</pre></div>

<p>then in the body of <code>g</code>, <code>w</code> will be the list <code>(1 2 3 4 5 6)</code>.
</p>
<p>Use this notation to write a procedure <code>same-parity</code> that takes one or more integers and returns a list of all the arguments that have the same even-odd parity as the first argument. For example,
</p>
<div class="example">
<pre class="example">(same-parity 1 2 3 4 5 6 7)
(1 3 5 7)

(same-parity 2 3 4 5 6 7)
(2 4 6)
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d20"></span>
<div class="example">
<pre class="example">(define (filter predicate items)
  (define (iter items result)
    (if (null? items)
        result
        (iter (cdr items)
              (if (predicate (car items))
                  (cons (car items) result)
                  result))))
  (reverse (iter items nil)))

(define (same-parity x . items)
  (let ((pred (if (odd? x)
                  odd?
                  even?)))
    (cons x (filter pred items))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.28: </strong>exercise-2-20</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;exercise-2-18&gt;&gt;
&lt;&lt;exercise-2-20&gt;&gt;
(p (same-parity 1 2 3 4 5 6 7))
(p (same-parity 2 3 4 5 6 7))
</pre></div>

<div class="example">
<pre class="example">

(1 3 5 7)
(2 4 6)
</pre></div>

</li><li> Exercise 2.21


<span id="Exercise-221-_00281_0029"></span><span id="index-2_002e21-square_002dlist"></span>

<p>The procedure square-list takes a list of numbers as argument and returns a list of the squares of those numbers.
</p>
<div class="example">
<pre class="example">(square-list (list 1 2 3 4))
(1 4 9 16)
</pre></div>

<p>Here are two different definitions of square-list. Complete both of them by filling in the missing expressions:
</p>
<div class="example">
<pre class="example">(define (square-list items)
  (if (null? items)
      nil
      (cons ⟨??⟩ ⟨??⟩)))

(define (square-list items)
  (map ⟨??⟩ ⟨??⟩))
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d21"></span>
<div class="example">
<pre class="example">(define (square-list items)
  (if (null? items)
      nil
      (cons (square (car items))
            (square-list (cdr items)))))

(define (square-list items)
  (map square items))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.29: </strong>exercise-2-21</p></div></div>
</li><li> Exercise 2.22


<span id="Exercise-222-_00281_0029"></span><span id="index-2_002e22-cons-order"></span>

<p>Louis Reasoner tries to rewrite the first <code>square-list</code> procedure of <a href="#Exercise-221-_00281_0029">Exercise 221 (1)</a> so that it evolves an iterative process:
</p>
<div class="example">
<pre class="example">(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons (square (car things))
                    answer))))
  (iter items nil))
</pre></div>

<p>Unfortunately, defining <code>square-list</code> this way produces the answer list in the reverse order of the one desired. Why?
</p>
<p>Louis then tries to fix his bug by interchanging the arguments to cons:
</p>
<div class="example">
<pre class="example">(define (square-list items)
  (define (iter things answer)
    (if (null? things)
        answer
        (iter (cdr things)
              (cons answer
                    (square
                     (car things))))))
  (iter items nil))
</pre></div>

<p>This doesn’t work either. Explain.
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">(square-list '(1 2 3 4))

;; 1
(cons 16 (cons 9 (cons 4 (cons 1 nil))))

;; 2
(cons (cons (cons (cons nil 1) 4) 9) 16)
</pre></div>

</li><li> Exercise 2.23


<span id="Exercise-223-_00281_0029"></span><span id="index-2_002e23-for_002deach"></span>

<p>The procedure <code>for-each</code> is similar to <code>map</code>. It takes as arguments a procedure and a list of elements. However, rather than forming a list of the results, <code>for-each</code> just applies the procedure to each of the elements in turn, from left to right. The values returned by applying the procedure to the elements are not used at all—~for-each~ is used with procedures that perform an action, such as printing. For example,
</p>
<div class="example">
<pre class="example">(for-each
 (lambda (x) (newline) (display x))
 (list 57 321 88))

57
321
88
</pre></div>

<p>The value returned by the call to <code>for-each</code> (not illustrated above) can be something arbitrary, such as true. Give an implementation of <code>for-each</code>.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d23"></span>
<div class="example">
<pre class="example">(define (for-each procedure items)
  (cond ((not (null? items))
         (procedure (car items))
         (for-each procedure (cdr items)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.30: </strong>exercise-2-23</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;exercise-2-23&gt;&gt;
(for-each
 (lambda (x) (newline) (display x))
 (list 57 321 88))
</pre></div>

<div class="example">
<pre class="example">

57
321
88
</pre></div>
</li></ol>

<hr>
<span id="Hierarchical-Structures"></span><div class="header">
<p>
Next: <a href="#Sequences-as-Conventional-Interfaces" accesskey="n" rel="next">Sequences as Conventional Interfaces</a>, Previous: <a href="#Representing-Sequences" accesskey="p" rel="prev">Representing Sequences</a>, Up: <a href="#Hierarchical-Data-and-the-Closure-Property" accesskey="u" rel="up">Hierarchical Data and the Closure Property</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Hierarchical-Structures-1"></span><h4 class="subsection">2.2.2 Hierarchical Structures</h4>

<div class="example">
<pre class="example">(cons (list 1 2) (list 3 4))
</pre></div>

<div class="float">
<img src="images/aef6ce3.svg" alt="images/aef6ce3">

<div class="float-caption"><p><strong>Figure: </strong>Structure formed by (cons (list 1 2) (list 3 4)).</p></div></div>
<div class="float"><span id="a5ab729"></span>
<img src="images/6052d94.svg" alt="images/6052d94">

<div class="float-caption"><p><strong>Figure 2.1: </strong>The list structure in viewed as a tree.</p></div></div>
<div class="example">
<pre class="example">(define (count-leaves x)
  (cond ((null? x) 0)
        ((not (pair? x)) 1)
        (else (+ (count-leaves (car x))
                 (count-leaves (cdr x))))))
</pre></div>

<ol>
<li> Exercise 2.24


<span id="Exercise-224-_00281_0029"></span><span id="index-2_002e24-structure"></span>

<p>Suppose we evaluate the expression <code>(list 1 (list 2 (list 3 4)))</code>. Give the result printed by the interpreter, the corresponding box-and-pointer structure, and the interpretation of this as a tree (as in <a href="#a5ab729">Figure 2.1</a>).
</p>
<p><strong>Solution</strong>
</p>
<img src="images/9dff2d4.svg" alt="images/9dff2d4">

<img src="images/9ec511a.svg" alt="images/9ec511a">

</li><li> Exercise 2.25


<span id="Exercise-225-_00281_0029"></span><span id="index-2_002e25-access-list-element"></span>

<p>Give combinations of cars and cdrs that will pick 7 from each of the following lists:
</p>
<div class="example">
<pre class="example">(1 3 (5 7) 9)
((7))
(1 (2 (3 (4 (5 (6 7))))))
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
(define (a x) (car (cdaddr x)))
(define (b x) (caar x))
(define (c x) (cadadr (cadadr (cadadr x))))

(p (a '(1 3 (5 7) 9)))
(p (b '((7))))
(p (c '(1 (2 (3 (4 (5 (6 7))))))))
</pre></div>

<div class="example">
<pre class="example">

7
7
7
</pre></div>

</li><li> Exercise 2.26


<span id="Exercise-226-_00281_0029"></span><span id="index-2_002e26-combine-list"></span>

<p>Suppose we define x and y to be two lists:
</p>
<div class="example">
<pre class="example">(define x (list 1 2 3))
(define y (list 4 5 6))
</pre></div>

<p>What result is printed by the interpreter in response to evaluating each of the following expressions:
</p>
<div class="example">
<pre class="example">(append x y)
(cons x y)
(list x y)
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
(define x (list 1 2 3))
(define y (list 4 5 6))
(p (append x y))
(p (cons x y))
(p (list x y))
</pre></div>

<div class="example">
<pre class="example">

(1 2 3 4 5 6)
((1 2 3) 4 5 6)
((1 2 3) (4 5 6))
</pre></div>

</li><li> Exercise 2.27


<span id="Exercise-227-_00281_0029"></span><span id="index-2_002e27-deep_002dreverse"></span>

<p>Modify your reverse procedure of <a href="#Exercise-218-_00281_0029">Exercise 218 (1)</a> to produce a <code>deep-reverse</code> procedure that takes a list as argument and returns as its value the list with its elements reversed and with all sublists deep-reversed as well. For example,
</p>
<div class="example">
<pre class="example">(define x
  (list (list 1 2) (list 3 4)))

x
((1 2) (3 4))

(reverse x)
((3 4) (1 2))

(deep-reverse x)
((4 3) (2 1))
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d27"></span>
<div class="example">
<pre class="example">(define (deep-reverse items)
  (define (iter items result)
      (if (null? items)
          result
          (let ((current (car items))
                (rest (cdr items)))
            (iter rest (cons (if (pair? current)
                                 (deep-reverse current)
                                 current)
                             result)))))
  (iter items nil))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.31: </strong>exercise-2-27</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;exercise-2-18&gt;&gt;
&lt;&lt;exercise-2-27&gt;&gt;
(define x (list (list 1 2) (list 3 4)))
(p x)
(p (reverse x))
(p (deep-reverse x))
</pre></div>

<div class="example">
<pre class="example">

((1 2) (3 4))
((3 4) (1 2))
((4 3) (2 1))
</pre></div>

</li><li> Exercise 2.28


<span id="Exercise-228-_00281_0029"></span><span id="index-2_002e28-fringe-tree"></span>
<span id="index-fringe-tree"></span>

<p>Write a procedure <code>fringe</code> that takes as argument a tree (represented as a list) and returns a list whose elements are all the leaves of the tree arranged in left-to-right order. For example,
</p>
<div class="example">
<pre class="example">(define x
  (list (list 1 2) (list 3 4)))

(fringe x)
(1 2 3 4)

(fringe (list x x))
(1 2 3 4 1 2 3 4)
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d28"></span>
<div class="example">
<pre class="example">(define (fringe tree)
  (define (leaf? x) (not (pair? x)))
  (define (iter tree result)
    (cond ((null? tree) result)
          ((leaf? tree) (cons tree result))
          (else (iter (car tree)
                      (iter (cdr tree) result)))))
  (iter tree nil))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.32: </strong>exercise-2-28</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-2-28&gt;&gt;
(define x (list (list 1 2) (list 3 4)))
(p (fringe x))
(p (fringe (list x x)))
</pre></div>

</li><li> Exercise 2.29


<span id="Exercise-229-_00281_0029"></span><span id="index-2_002e29"></span>

<p>A binary mobile consists of two branches, a left branch and a right branch. Each branch is a rod of a certain length, from which hangs either a weight or another binary mobile. We can represent a binary mobile using compound data by constructing it from two branches (for example, using <code>list</code>):
</p>
<div class="example">
<pre class="example">(define (make-mobile left right)
  (list left right))
</pre></div>

<p>A branch is constructed from a <code>length</code> (which must be a number) together with a <code>structure</code>, which may be either a number (representing a simple weight) or another mobile:
</p>
<div class="example">
<pre class="example">(define (make-branch length structure)
  (list length structure))
</pre></div>

<ol>
<li> Write the corresponding selectors <code>left-branch</code> and <code>right-branch</code>, which return the branches of a mobile, and <code>branch-length</code> and <code>branch-structure</code>, which return the components of a branch.
</li><li> Using your selectors, define a procedure <code>total-weight</code> that returns the total weight of a mobile.
</li><li> A mobile is said to be <em>balanced</em> if the torque applied by its top-left branch is equal to that applied by its top-right branch (that is, if the length of the left rod multiplied by the weight hanging from that rod is equal to the corresponding product for the right side) and if each of the submobiles hanging off its branches is balanced. Design a predicate that tests whether a binary mobile is balanced.
</li><li> Suppose we change the representation of mobiles so that the constructors are
<div class="example">
<pre class="example">(define (make-mobile left right)
  (cons left right))

(define (make-branch length structure)
  (cons length structure))
</pre></div>
<p>How much do you need to change your programs to convert to the new representation?
</p></li></ol>


<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d29"></span>
<div class="example">
<pre class="example">;;; 1
(define (make-mobile left right) (list left right))
(define (left-branch mobile) (car mobile))
(define (right-branch mobile) (cadr mobile))

(define (make-branch length structure) (list length structure))
(define (branch-length branch) (car branch))
(define (branch-structure branch) (cadr branch))

;;; 2
(define mobile? pair?)
(define (branch-weight branch)
    (let ((structure (branch-structure branch)))
      (if (mobile? structure)
          (total-weight structure)
          structure)))
(define (total-weight mobile)
  (+ (branch-weight (left-branch mobile))
     (branch-weight (right-branch mobile))))

;;; 3
(define (branch-torque branch)
  (* (branch-length branch)
     (branch-weight branch)))

(define (branch-balanced? branch)
  (let ((structure (branch-structure branch)))
    (if (mobile? structure)
        (balanced? structure)
        #t)))

(define (balanced? mobile)
  (let ((lb (left-branch mobile))
        (rb (right-branch mobile)))
    (and (= (branch-torque lb) (branch-torque rb))
         (branch-balanced? lb)
         (branch-balanced? rb))))

;;; 4
(define (make-mobile left right)
  (cons left right))
(define (make-branch length structure)
  (cons length structure))
(define (left-branch mobile) (car mobile))
(define (right-branch mobile) (cdr mobile))
(define (branch-length branch) (car branch))
(define (branch-structure branch) (cdr branch))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.33: </strong>exercise-2-29</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-2-29&gt;&gt;
(define b1 (make-branch 2 4))
(define b2 (make-branch 1 8))
(define m1 (make-mobile b1 b2))
(define b3 (make-branch 3 m1))
(define b4 (make-branch 4 8))
(define m2 (make-mobile b3 b4))
(p (total-weight m2)) ;20
(p (total-weight m1)) ;12
(p (balanced? m2)) ;#f
(p (balanced? m1)) ;#t
</pre></div>

<div class="example">
<pre class="example">

20
12
#f
#t
</pre></div>

</li><li> Mapping over trees


<span id="index-scale_002dtree"></span>

<p><code>Map</code> together with recursion is a powerful abstraction for dealing with trees.
</p>
<div class="float"><span id="scale_002dtree"></span>
<div class="example">
<pre class="example">(define (leaf? x) (not (pair? x)))
(define (tree? x) (pair? x))
(define (scale-tree tree factor)
  (cond ((null? tree) nil)
        (leaf? tree (* tree factor))
        (else
         (cons (scale-tree (car tree) factor)
               (scale-tree (cdr tree) factor)))))
(define (scale-tree tree factor)
  (map (lambda (sub-tree)
         (if (tree? sub-tree)
             (scale-tree sub-tree factor)
             (* sub-tree factor)))
       tree))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.34: </strong>scale-tree</p></div></div>
</li><li> Exercise 2.30


<span id="Exercise-230-_00281_0029"></span><span id="index-2_002e30-square_002dtree"></span>

<p>Define a procedure <code>square-tree</code> analogous to the <code>square-list</code> procedure of <a href="#Exercise-221-_00281_0029">Exercise 221 (1)</a>. That is, <code>square-tree</code> should behave as follows:
</p>
<div class="example">
<pre class="example">(square-tree
 (list 1
       (list 2 (list 3 4) 5)
       (list 6 7)))
(1 (4 (9 16) 25) (36 49))
</pre></div>

<p>Define <code>square-tree~</code> both directly (i.e., without using any higher-order procedures) and also by using <code>map</code> and recursion.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d30_002d1"></span>
<div class="example">
<pre class="example">(define (leaf? x) (not (pair? x)))
(define (tree? x) (pair? x))
(define (square-tree tree)
  (cond ((null? tree) nil)
        ((leaf? tree) (square tree))
        (else
         (cons (square-tree (car tree))
               (square-tree (cdr tree))))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.35: </strong>exercise-2-30-1</p></div></div>
<div class="float"><span id="exercise_002d2_002d30_002d2"></span>
<div class="example">
<pre class="example">(define (leaf? x) (not (pair? x)))
(define (tree? x) (pair? x))
(define (square-tree tree)
  (map (lambda (subtree)
         (if (tree? subtree)
             (square-tree subtree)
             (square subtree)))
       tree))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.36: </strong>exercise-2-30-2</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-2-30-1&gt;&gt;
(p (square-tree
    (list 1
          (list 2 (list 3 4) 5)
          (list 6 7))))
&lt;&lt;exercise-2-30-2&gt;&gt;
(p (square-tree
    (list 1
          (list 2 (list 3 4) 5)
          (list 6 7))))
</pre></div>

<div class="example">
<pre class="example">

(1 (4 (9 16) 25) (36 49))
(1 (4 (9 16) 25) (36 49))
</pre></div>

</li><li> Exercise 2.31


<span id="Exercise-231-_00281_0029"></span><span id="index-2_002e31-tree_002dmap"></span>

<p>Abstract your answer to <a href="#Exercise-230-_00281_0029">Exercise 230 (1)</a> to produce a procedure <code>tree-map</code> with the property that <code>square-tree</code> could be defined as
</p>
<div class="example">
<pre class="example">(define (square-tree tree)
  (tree-map square tree))
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d31"></span>
<div class="example">
<pre class="example">(define (leaf? tree) (not (pair? tree)))
(define (tree-map proc tree)
  (cond ((null? tree) nil)
        ((leaf? tree) (proc tree))
        (else
         (cons (tree-map proc (car tree))
               (tree-map proc (cdr tree))))))

(define (tree-map proc tree)
  (map (lambda (subtree)
         (if (pair? subtree)
             (tree-map proc subtree)
             (proc subtree)))
       tree))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.37: </strong>exercise-2-31</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-2-31&gt;&gt;
(define (square-tree tree)
  (tree-map square tree))
(p (square-tree
    (list 1
          (list 2 (list 3 4) 5)
          (list 6 7))))
</pre></div>

<div class="example">
<pre class="example">

(1 (4 (9 16) 25) (36 49))
</pre></div>

</li><li> Exercise 2.32


<span id="Exercise-232-_00281_0029"></span><span id="index-2_002e32-generate-the-set-of-subsets-of-a-set"></span>
<span id="index-subsets"></span>

<p>We can represent a set as a list of distinct elements, and we can represent the set of all subsets of the set as a list of lists. For example, if the set is <code>(1 2 3)</code>, then the set of all subsets is <code>(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))</code>. Complete the following definition of a procedure that generates the set of subsets of a set and give a clear explanation of why it works:
</p>
<div class="example">
<pre class="example">(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map ⟨??⟩ rest)))))
</pre></div>

<p><strong>Solution</strong>
</p>
<p>The set of subsets of a given set is the union of:
</p>
<p>A. the set of all subsets excluding the first number.
B. the set of all subsets including the first number, i.e., bullet A subsets with the first number re-inserted into each subset.
</p>
<p>The whole explanation is:
</p>
<p>Step 1: given the set (3). Bullet A gives the subset (), and bullet B gives (3). Step 1 result is (), (3).
</p>
<p>Step 2: given the set (2, 3). Bullet A gives the subsets of step 1 result, (), (3). Bullet B gives the subsets of step 1 result with 2 insert into each subset, (2), (2, 3). Step 2 result is (), (3), (2), (2, 3).
</p>
<p>Step 3: given the set (1, 2, 3). Bullet A gives the subsets of Step 2, (), (3), (2), (2, 3). Bullet B gives subsets of step 2 with 1 insert into each subset, (1), (1, 3), (1, 2), (1, 2, 3).
</p>
<div class="float"><span id="exercise_002d2_002d32"></span>
<div class="example">
<pre class="example">(define (subsets s)
  (if (null? s)
      (list nil)
      (let ((rest (subsets (cdr s))))
        (append rest (map (lambda (x)
                            (cons (car s) x))
                          rest)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.38: </strong>exercise-2-32</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-2-32&gt;&gt;
(p (subsets '(1 2 3)))
</pre></div>

<div class="example">
<pre class="example">

(() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3))
</pre></div>
</li></ol>

<hr>
<span id="Sequences-as-Conventional-Interfaces"></span><div class="header">
<p>
Next: <a href="#Example-A-Picture-Language" accesskey="n" rel="next">Example A Picture Language</a>, Previous: <a href="#Hierarchical-Structures" accesskey="p" rel="prev">Hierarchical Structures</a>, Up: <a href="#Hierarchical-Data-and-the-Closure-Property" accesskey="u" rel="up">Hierarchical Data and the Closure Property</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Sequences-as-Conventional-Interfaces-1"></span><h4 class="subsection">2.2.3 Sequences as Conventional Interfaces</h4>

<ul>
<li> What are the benefits of sequences as conventional interfaces?

<p>Sequences, implemented here as lists, serve as a conventional interface that permits us to combine processing modules.
</p>
<p>Additionally, when we uniformly represent structures as sequences, we have localized the data-structure dependencies in our programs to a small number of sequence operations.By changing these, we can experiment with alternative representations of sequences, while leaving the overall design of our programs intact.
</p>
</li><li> What is the key to organizing programs so as to more clearly reflect the signal-flow structure?

<p>Concentrate on the “signals” that flow from one stage in the process to the next.
</p></li></ul>


<div class="float"><span id="sequence_002doperations"></span>
<div class="example">
<pre class="example">(define (filter predicate sequence)
  (cond ((null? sequence) nil)
        ((predicate (car sequence))
         (cons (car sequence)
               (filter predicate
                       (cdr sequence))))
        (else  (filter predicate
                       (cdr sequence)))))
(define (accumulate op initial sequence)
  (if (null? sequence)
      initial
      (op (car sequence)
          (accumulate op
                      initial
                      (cdr sequence)))))
(define (enumerate-interval low high)
  (if (&gt; low high)
      nil
      (cons low
            (enumerate-interval
             (+ low 1)
             high))))
(define (enumerate-tree tree)
  (cond ((null? tree) nil)
        ((not (pair? tree)) (list tree))
        (else (append
               (enumerate-tree (car tree))
               (enumerate-tree (cdr tree))))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.39: </strong>sequence-operations</p></div></div>
<ol>
<li> Exercise 2.33


<span id="Exercise-233-_00281_0029"></span><span id="index-2_002e33-list_002dmanipulation-operations-as-accumulations"></span>

<p>Fill in the missing expressions to complete the following definitions of some basic list-manipulation operations as accumulations:
</p>
<div class="example">
<pre class="example">(define (map p sequence)
  (accumulate (lambda (x y) ⟨??⟩)
              nil sequence))

(define (append seq1 seq2)
  (accumulate cons ⟨??⟩ ⟨??⟩))

(define (length sequence)
  (accumulate ⟨??⟩ 0 sequence))
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d33"></span>
<div class="example">
<pre class="example">(define (map p sequence)
  (accumulate (lambda (x y) (p x))
              nil sequence))

(define (append seq1 seq2)
  (accumulate cons seq2 seq1))

(define (length sequence)
  (accumulate (lambda (x y) (+ 1 y)) 0 sequence))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.40: </strong>exercise-2-33</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;sequence-operations&gt;&gt;
&lt;&lt;exercise-2-33&gt;&gt;
(map display '(1 2 3))
(p (append '(1 2 3) '(4 5 6)))
(p (length '(1 2 3)))
</pre></div>

</li><li> Exercise 2.34


<span id="Exercise-234-_00281_0029"></span><span id="index-2_002e34-Horner_2019s-rule"></span>

<p>Evaluating a polynomial in \( x \) at a given value of \( x \) can be formulated as an accumulation. We evaluate the polynomial
</p>
<p>\[  a_nx^n + a_{n-1}x^{n-1} + \dotsb + a_1x + a_0 \]
</p>
<p>using a well-known algorithm called <em>Horner’s rule</em>, which structures the computation as
</p>
<p>\[  (\dots(a_nx+a_{n-1})x+\dotsb +a_1)x + a_0. \]
</p>
<p>In other words, we start with \( a_n \) , multiply by \( x \), add \( a_{n-1} \) , multiply by \( x \), and so on, until we reach \( a_0 \).
</p>
<p>Fill in the following template to produce a procedure that evaluates a polynomial using <em>Horner’s rule</em>. Assume that the coefficients of the polynomial are arranged in a sequence, from \( a_0 \) through \( a_n \).
</p>
<div class="example">
<pre class="example">(define
  (horner-eval x coefficient-sequence)
  (accumulate
   (lambda (this-coeff higher-terms)
     ⟨??⟩)
   0
   coefficient-sequence))
</pre></div>

<p>For example, to compute \( 1+3x +5x^3 +x^5 \) at \( x = 2 \) you would evaluate
</p>
<div class="example">
<pre class="example">(horner-eval 2 (list 1 3 0 5 0 1))
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d34"></span>
<div class="example">
<pre class="example">(define
  (horner-eval x coefficient-sequence)
  (accumulate
   (lambda (this-coeff higher-terms)
     (+ this-coeff
        (* x higher-terms)))
   0
   coefficient-sequence))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.41: </strong>exercise-2-34</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;sequence-operations&gt;&gt;
&lt;&lt;exercise-2-34&gt;&gt;
(p (horner-eval 2 (list 1 3 0 5 0 1)))
</pre></div>

<div class="example">
<pre class="example">

79
</pre></div>

</li><li> Exercise 2.35


<span id="Exercise-235-_00281_0029"></span><span id="index-2_002e35-count_002dleaves-with-accumulation"></span>

<p>Redefine <code>count-leaves</code> from <a href="#Hierarchical-Structures">Hierarchical Structures</a> as an accumulation:
</p>
<div class="example">
<pre class="example">(define (count-leaves t)
  (accumulate ⟨??⟩ ⟨??⟩ (map ⟨??⟩ ⟨??⟩)))
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d35"></span>
<div class="example">
<pre class="example">(define (count-leaves t)
  (accumulate + 0 (map (lambda (x) 1)
                       (enumerate-tree t))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.42: </strong>exercise-2-35</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;sequence-operations&gt;&gt;
&lt;&lt;exercise-2-35&gt;&gt;
(p (count-leaves '(1 (2 3 4) (5 6) (7))))
</pre></div>

<div class="example">
<pre class="example">

7
</pre></div>

</li><li> Exercise 2.36


<span id="Exercise-236-_00281_0029"></span><span id="index-2_002e36-accumulate_002dn"></span>
<span id="index-accumulate_002dn"></span>

<p>The procedure <code>accumulate-n</code> is similar to <code>accumulate</code> except that it takes as its third argument a sequence of sequences, which are all assumed to have the same number of elements. It applies the designated accumulation procedure to combine all the first elements of the sequences, all the second elements of the sequences, and so on, and returns a sequence of the results. For instance, if s is a sequence containing four sequences, <code>((1 2 3) (4 5 6) (7 8 9) (10 11 12))</code>, then the value of <code>(accumulate-n + 0 s)</code> should be the sequence <code>(22 26 30)</code>. Fill in the missing expressions in the following definition of <code>accumulate-n</code>:
</p>
<div class="example">
<pre class="example">(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init ⟨??⟩)
            (accumulate-n op init ⟨??⟩))))
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d36"></span>
<div class="example">
<pre class="example">(define (accumulate-n op init seqs)
  (if (null? (car seqs))
      nil
      (cons (accumulate op init
                        (map (lambda (x) (car x)) seqs))
            (accumulate-n op init
                          (map (lambda (x) (cdr x)) seqs)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.43: </strong>exercise-2-36</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;sequence-operations&gt;&gt;
&lt;&lt;exercise-2-36&gt;&gt;
(p (accumulate-n + 0
                 '((1 2 3) (4 5 6) (7 8 9) (10 11 12))))
</pre></div>

<div class="example">
<pre class="example">

(22 26 30)
</pre></div>

</li><li> Exercise 2.37


<span id="Exercise-237-_00281_0029"></span><span id="index-2_002e37-matrix"></span>

<p>Suppose we represent vectors \( \mathbf{v} = (v_i) \) as sequences of numbers, and matrices \( \mathbf{m} = (m_{ij}) \) as sequences of vectors (the rows of the matrix). For example, the matrix
</p>
<p>\begin{bmatrix}
       1 &amp; 2 &amp; 3 &amp; 4 \\
       4 &amp; 5 &amp; 6 &amp; 6 \\
       6 &amp; 7 &amp; 8 &amp; 9
     \end{bmatrix}
</p>
<p>is represented as the sequence <code>((1 2 3 4) (4 5 6 6) (6 7 8 9))</code>. With this representation, we can use sequence operations to concisely express the basic matrix and vector operations. These operations (which are described in any book on matrix algebra) are the following:
</p>
<p>\begin{array}{rl}
       \text{(dot-product v w)} &amp; \text{returns the sum}\
       \sum_i v_iw_i; \\
       \text{(matrix-*-vector m v)}
       &amp; \text{returns the vector}\ \mathbf{t},\
       \text{where}\ t_i=\sum_jm_{ij}v_j; \\
       \text{(matrix-*-matrix m n)}
       &amp; \text{returns the matrix}\ \mathbf{p},\
       \text{where}\ p_{ij}=\sum_km_{ik}n_{kj}; \\
       \text{(transpose m)} &amp; \text{returns the matrix}\ \mathbf{n},\
       \text{where}\ n_{ij}=m_{ji}.
     \end{array}
</p>
<p>We can define the dot product as
</p>
<div class="example">
<pre class="example">(define (dot-product v w)
  (accumulate + 0 (map * v w)))
</pre></div>

<p>Fill in the missing expressions in the following procedures for computing the other matrix operations. (The procedure <code>accumulate-n</code> is defined in <a href="#Exercise-236-_00281_0029">Exercise 236 (1)</a>.)
</p>
<div class="example">
<pre class="example">(define (matrix-*-vector m v)
  (map (lambda (row) accumulate   ) m))

(define (transpose mat)
  (accumulate-n ⟨??⟩ ⟨??⟩ mat))

(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map ⟨??⟩ m)))
</pre></div>

<p><strong>Solution</strong>
</p>
<p>(matrix-*-vector m v)
</p>
<p>\begin{align*}
       \begin{bmatrix}
         1 &amp; 2 &amp; 3 \\
         4 &amp; 5 &amp; 6 \\
       \end{bmatrix}
       \cdot
       \begin{bmatrix}
         10 \\ 11 \\ 12
       \end{bmatrix}
       &amp;=
       10 \cdot \begin{bmatrix}
         1 \\ 4
       \end{bmatrix} +
       11 \cdot \begin{bmatrix}
         2 \\ 5
       \end{bmatrix} +
       12 \cdot \begin{bmatrix}
         3 \\ 6
       \end{bmatrix} \\
       &amp;=
       \begin{bmatrix}
         10*1+11*2+12*3 \\
         10*4+11*5+12*6
       \end{bmatrix} \\
       &amp;=
       \begin{bmatrix}
         68 \\167
       \end{bmatrix}
     \end{align*}
</p>

<div class="float"><span id="exercise_002d2_002d37"></span>
<div class="example">
<pre class="example">(define (dot-product v w)
  (accumulate + 0 (map * v w)))

(define (matrix-*-vector m v)
  (map (lambda (row)
         (dot-product row v))
       m))

(define (transpose mat)
  (accumulate-n cons nil mat))

(define (matrix-*-matrix m n)
  (let ((cols (transpose n)))
    (map (lambda (row)
           (matrix-*-vector cols row))
         m)))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.44: </strong>exercise-2-37</p></div></div>
<div class="example">
<pre class="example">(define scheme-map map)
&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;sequence-operations&gt;&gt;
&lt;&lt;exercise-2-36&gt;&gt;
&lt;&lt;exercise-2-37&gt;&gt;
(define map scheme-map)
(define m1 '((1 2 3) (4 5 6)))
(define m2 '((1 2) (4 5) (6 7)))
(define v '(10 11 12))
(p (dot-product v v))
(p (matrix-*-vector m1 v))
(p (transpose m1))
(p (matrix-*-matrix m1 m2))
</pre></div>

<div class="example">
<pre class="example">

365
(68 167)
((1 4) (2 5) (3 6))
((27 33) (60 75))
</pre></div>

</li><li> Exercise 2.38


<span id="Exercise-238-_00281_0029"></span><span id="index-2_002e38-fold_002dright-fold_002dleft"></span>
<span id="index-fold_002dleft"></span>

<p>The accumulate procedure is also known as <code>fold-right</code>, because it combines the first element of the sequence with the result of combining all the elements to the right. There is also a <code>fold-left</code>, which is similar to <code>fold-right</code>, except that it combines elements working in the opposite direction:
</p>
<div class="float"><span id="exercise_002d2_002d38_002dq"></span>
<div class="example">
<pre class="example">(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.45: </strong>exercise-2-38-q</p></div></div>
<p>What are the values of
</p>
<div class="example">
<pre class="example">(fold-right / 1 (list 1 2 3))
(fold-left  / 1 (list 1 2 3))
(fold-right list nil (list 1 2 3))
(fold-left  list nil (list 1 2 3))
</pre></div>

<p>Give a property that op should satisfy to guarantee that <code>fold-right</code> and <code>fold-left</code> will produce the same values for any sequence.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d38"></span>
<div class="example">
<pre class="example">(define fold-right accumulate)
(define (fold-left op initial sequence)
  (define (iter result rest)
    (if (null? rest)
        result
        (iter (op result (car rest))
              (cdr rest))))
  (iter initial sequence))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.46: </strong>exercise-2-38</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;sequence-operations&gt;&gt;
&lt;&lt;exercise-2-38&gt;&gt;
(p (fold-right / 1 (list 1 2 3)))
(p (fold-left  / 1 (list 1 2 3)))
(p (fold-right list nil (list 1 2 3)))
(p (fold-left  list nil (list 1 2 3)))
</pre></div>

<div class="example">
<pre class="example">

3/2
1/6
(1 (2 (3 ())))
(((() 1) 2) 3)
</pre></div>


<p>Suppose <code>(fold-right f i '(a)) = (fold-left f i '(a))</code>, then
</p>
<div class="example">
<pre class="example">(fold-right f i '(a)) = (f a i)
(fold-left f i '(a)) = (f i a)
</pre></div>

<p>so <code>(f a i) = (f i a)</code>, commutative is required.
</p>
<p>Also
</p>
<div class="example">
<pre class="example">(fold-right f i '(a b))
= (f (f i a) b)
= (f (f a i) b)
(fold-left f i '(a b))
= (f a (f b i))
= (f a (f i b))
</pre></div>

<p>so <code>(f (f a i) b) = (f a (f i b))</code>, associative is required.
</p>
</li><li> Exercise 2.39


<span id="Exercise-239-_00281_0029"></span><span id="index-2_002e39"></span>

<p>Complete the following definitions of <code>reverse</code> (<a href="#Exercise-218-_00281_0029">Exercise 218 (1)</a>) in terms of <code>fold-right</code> and <code>fold-left</code> from <a href="#Exercise-238-_00281_0029">Exercise 238 (1)</a>:
</p>
<div class="example">
<pre class="example">(define (reverse sequence)
  (fold-right
   (lambda (x y) ⟨??⟩) nil sequence))

(define (reverse sequence)
  (fold-left
   (lambda (x y) ⟨??⟩) nil sequence))
</pre></div>

<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d39_002d1"></span>
<div class="example">
<pre class="example">(define (reverse sequence)
  (fold-right (lambda (first result)
                (append result (list first)))
              nil
              sequence))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.47: </strong>exercise-2-39-1</p></div></div>
<div class="float"><span id="exercise_002d2_002d39_002d2"></span>
<div class="example">
<pre class="example">(define (reverse sequence)
  (fold-left (lambda (result first)
               (cons first result))
             nil
             sequence))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.48: </strong>exercise-2-39-2</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;sequence-operations&gt;&gt;
&lt;&lt;exercise-2-38&gt;&gt;
&lt;&lt;exercise-2-39-1&gt;&gt;
(p (reverse '(1 2 3)))
&lt;&lt;exercise-2-39-2&gt;&gt;
(p (reverse '(1 2 3)))
</pre></div>

</li><li> Nested Mappings


<span id="index-flatmap"></span>
<span id="index-permutations"></span>

<ul>
<li> How to extend the sequence paradigm to include many computations that are commonly expressed using nested loops?

<div class="float"><span id="flatmap"></span>
<div class="example">
<pre class="example">(define (flatmap proc seq)
  (accumulate append nil (map proc seq)))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.49: </strong>flatmap</p></div></div>
<div class="float"><span id="prime_002dsum_002dpairs"></span>
<div class="example">
<pre class="example">(define (prime-sum? pair)
  (prime? (+ (car pair) (cadr pair))))
(define (make-pair-sum pair)
  (list (car pair)
        (cadr pair)
        (+ (car pair) (cadr pair))))
(define (unique-pairs n)
  (flatmap
   (lambda (i)
     (map (lambda (j) (list i j))
          (enumerate-interval 1 (- i 1))))
   (enumerate-interval 1 n)))
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum? (unique-pairs n))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.50: </strong>prime-sum-pairs</p></div></div>
<p>See also <a href="#exercise_002d2_002d41">unique-triples</a>.
</p></li></ul>

<p>Two nested <code>map</code> form two layers of lists, <code>append</code> removes a layer:
</p>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;sequence-operations&gt;&gt;
(define (cons-to n)
  (accumulate
   cons
   nil
   (map (lambda (i)
          (map (lambda (j)
                 ;; (() ((2 1)) ((3 1) (3 2))
                 (list i j))
               ;; (() (1) (1 2))
               (enumerate-interval 1 (- i 1))))
        ;; (1 2 3)
        (enumerate-interval 1 n))))
(p (cons-to 3))

(define (append-to n)
  (accumulate
   append
   nil
   (map (lambda (i)
          (map (lambda (j)
                 (list i j))
               (enumerate-interval 1 (- i 1))))
        (enumerate-interval 1 n))))
(p (append-to 3))
</pre></div>

<div class="example">
<pre class="example">

(() ((2 1)) ((3 1) (3 2)))
((2 1) (3 1) (3 2))
</pre></div>


<p>Here is a plan for generating the permutations of S: For each item x in S, recursively generate the sequence of permutations of S−x, and adjoin x to the front of each one. This yields, for each x in S, the sequence of permutations of S that begin with x. Combining these sequences for all x gives all the permutations of S:
</p>
<img src="./omni-exports/2-2-3-perm-2x.png" alt="./omni-exports/2-2-3-perm-2x">

<div class="float"><span id="permutations"></span>
<div class="example">
<pre class="example">(define (permutations s)
  (if (null? s)   ; empty set?
      (list nil)  ; sequence containing empty set
      (flatmap (lambda (x)
                 (map (lambda (p)
                        (cons x p))
                      (permutations
                       (remove x s))))
               s)))
(define (remove item sequence)
  (filter (lambda (x) (not (eq? x item)))
          sequence))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.51: </strong>permutations</p></div></div>
<p>See also <a href="#Exercise-232-_00281_0029">Exercise 232 (1)</a>.
</p>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;sequence-operations&gt;&gt;
&lt;&lt;flatmap&gt;&gt;
&lt;&lt;permutations&gt;&gt;
(p (permutations '(a b c)))
</pre></div>

</li><li> Exercise 2.40


<span id="Exercise-240-_00281_0029"></span><span id="index-2_002e40-improve-prime_002dsum_002dpairs"></span>

<p>Define a procedure <code>unique-pairs</code> that, given an integer n, generates the sequence of pairs \( (i,j) \) with \( 1 \leq j &lt; i \leq n \). Use <code>unique-pairs</code> to simplify the definition of <code>prime-sum-pairs</code> given above.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d40"></span>
<div class="example">
<pre class="example">(define (unique-pairs n)
  (flatmap (lambda (i)
             (map (lambda (j) (list i j))
                  (enumerate-interval 1 (- i 1))))
           (enumerate-interval 1 n)))
(define (prime-sum-pairs n)
  (map make-pair-sum
       (filter prime-sum? (unique-pairs n))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.52: </strong>exercise-2-40</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;searching-for-divisors&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;sequence-operations&gt;&gt;
&lt;&lt;flatmap&gt;&gt;
&lt;&lt;prime-sum-pairs&gt;&gt;
&lt;&lt;exercise-2-40&gt;&gt;
(p (prime-sum-pairs 5))
</pre></div>

<div class="example">
<pre class="example">

((2 1 3) (3 2 5) (4 1 5) (4 3 7) (5 2 7))
</pre></div>

</li><li> Exercise 2.41


<span id="Exercise-241-_00281_0029"></span><span id="index-2_002e41-triple-loops"></span>

<p>Write a procedure to find all ordered triples of distinct positive integers i, j, and k less than or equal to a given integer n that sum to a given integer s.
</p>
<p><strong>Solution</strong>
</p>
<p>\[ 1 \leq k &lt; j &lt; i \leq n \]
</p>
<div class="float"><span id="exercise_002d2_002d41"></span>
<div class="example">
<pre class="example">(define (unique-triples n)
  (flatmap
   (lambda (i)
     (flatmap
      (lambda (j)
        (map (lambda (k)
               (list i j k))
             (enumerate-interval 1 (- j 1))))
      (enumerate-interval 1 (- i 1))))
   (enumerate-interval 1 n)))
(define (sum-triples n s)
  (define (specified-sum? triples)
    (= (accumulate + 0 triples) s))
  (filter specified-sum? (unique-triples n)))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.53: </strong>exercise-2-41</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;sequence-operations&gt;&gt;
&lt;&lt;flatmap&gt;&gt;
&lt;&lt;exercise-2-41&gt;&gt;
(p (unique-triples 5))
(p (sum-triples 5 9))
</pre></div>

<div class="example">
<pre class="example">

((3 2 1) (4 2 1) (4 3 1) (4 3 2) (5 2 1) (5 3 1) (5 3 2) (5 4 1) (5 4 2) (5 4 3))
((4 3 2) (5 3 1))
</pre></div>

</li><li> Exercise 2.42


<span id="Exercise-242-_00281_0029"></span><span id="index-2_002e42-eight_002dqueens-puzzle"></span>

<p>The “eight-queens puzzle” asks how to place eight queens on a chessboard so that no queen is in check from any other (i.e., no two queens are in the same row, column, or diagonal). One possible solution is shown in Figure 2.8. One way to solve the puzzle is to work across the board, placing a queen in each column. Once we have placed k-1 queens, we must place the \( k^{th} \) queen in a position where it does not check any of the queens already on the board. We can formulate this approach recursively: Assume that we have already generated the sequence of all possible ways to place k-1 queens in the first k-1 columns of the board. For each of these ways, generate an extended set of positions by placing a queen in each row of the \( k^{th} \) column. Now filter these, keeping only the positions for which the queen in the \( k^{th} \) column is safe with respect to the other queens. This produces the sequence of all ways to place k queens in the first k columns. By continuing this process, we will produce not only one solution, but all solutions to the puzzle.
</p>
<table>
<tr><td>.</td><td>.</td><td>.</td><td>.</td><td>.</td><td>Q</td><td>.</td><td>.</td></tr>
<tr><td>.</td><td>.</td><td>Q</td><td>.</td><td>.</td><td>.</td><td>.</td><td>.</td></tr>
<tr><td>Q</td><td>.</td><td>.</td><td>.</td><td>.</td><td>.</td><td>.</td><td>.</td></tr>
<tr><td>.</td><td>.</td><td>.</td><td>.</td><td>.</td><td>.</td><td>Q</td><td>.</td></tr>
<tr><td>.</td><td>.</td><td>.</td><td>.</td><td>.</td><td>.</td><td>.</td><td>.</td></tr>
<tr><td>.</td><td>.</td><td>.</td><td>.</td><td>Q</td><td>.</td><td>.</td><td>.</td></tr>
<tr><td>.</td><td>Q</td><td>.</td><td>.</td><td>.</td><td>.</td><td>.</td><td>Q</td></tr>
<tr><td>.</td><td>.</td><td>.</td><td>Q</td><td>.</td><td>.</td><td>.</td><td>.</td></tr>
</table>

<p>We implement this solution as a procedure <code>queens</code>, which returns a sequence of all solutions to the problem of placing n queens on an n*n chessboard. Queens has an internal procedure <code>queen-cols</code> that returns the sequence of all ways to place queens in the first k columns of the board.
</p>
<div class="float"><span id="exercise_002d2_002d42_002dq"></span>
<div class="example">
<pre class="example">(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            ;; rest-of-queens is (Q1 Q2 .. Qk-1)
            ;; map below generates ((Q1 .. Qk-1 Qk_row1) (Q1 .. Qk_row2) ..)
            ;; makes rest-of-queens two level list
            (map (lambda (new-row)
                   (adjoin-position
                    new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          ;; (queen-cols (- k 1)) is ((Q1 Q2 .. Qk-1) (Q1 Q2 .. Qk-1) ..)
          (queen-cols (- k 1))))))
  (queen-cols board-size))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.54: </strong>exercise-2-42-q</p></div></div>
<p>In this procedure <code>rest-of-queens</code> is a way to place k-1 queens in the first k-1 columns, and <code>new-row</code> is a proposed row in which to place the queen for the \( k^{th} \) column. Complete the program by implementing the representation for sets of board positions, including the procedure <code>adjoin-position</code>, which adjoins a new row-column position to a set of positions, and <code>empty-board</code>, which represents an empty set of positions. You must also write the procedure <code>safe?</code>, which determines for a set of positions, whether the queen in the \( k^{th} \) column is safe with respect to the others. (Note that we need only check whether the new queen is safe—the other queens are already guaranteed safe with respect to each other.)
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d42a"></span>
<div class="example">
<pre class="example">(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list empty-board)
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position
                    new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))

;; (((row8 col8) (row7 col7) ...) ...)
(define (safe? k positions)
  (let ((trial (car positions))
        (trial-row (caar positions))
        (trial-col (cadar positions))
        (rest (cdr positions)))
    (accumulate (lambda (current result)
                  (let ((row (car current))
                        (col (cadr current)))
                    (and (not (= (- trial-row trial-col)
                                 (- row col)))
                         (not (= (+ trial-row trial-col)
                                 (+ row col)))
                         (not (= trial-row row))
                         result)))
                true
                rest)))

(define (adjoin-position row col rest)
  (cons (list row col) rest))

(define empty-board '())
</pre></div>

<div class="float-caption"><p><strong>Listing 2.55: </strong>exercise-2-42a</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;list&gt;&gt;
&lt;&lt;sequence-operations&gt;&gt;
&lt;&lt;flatmap&gt;&gt;
&lt;&lt;exercise-2-42-q&gt;&gt;
&lt;&lt;exercise-2-42a&gt;&gt;
(p (queens 4))
</pre></div>

<div class="example">
<pre class="example">

(((3 4) (1 3) (4 2) (2 1)) ((2 4) (4 3) (1 2) (3 1)))
</pre></div>

</li><li> Exercise 2.43


<span id="Exercise-243-_00281_0029"></span><span id="index-2_002e43"></span>

<p>Louis Reasoner is having a terrible time doing <a href="#Exercise-242-_00281_0029">Exercise 242 (1)</a>. His <code>queens</code> procedure seems to work, but it runs extremely slowly. (Louis never does manage to wait long enough for it to solve even the \( 6 \times 6 \) case.) When Louis asks Eva Lu Ator for help, she points out that he has interchanged the order of the nested mappings in the flatmap, writing it as
</p>
<div class="example">
<pre class="example">(flatmap
 (lambda (new-row)
   (map (lambda (rest-of-queens)
          (adjoin-position
           new-row k rest-of-queens))
        (queen-cols (- k 1))))
 (enumerate-interval 1 board-size))
</pre></div>

<p>Explain why this interchange makes the program run slowly. Estimate how long it will take Louis’s program to solve the eight-queens puzzle, assuming that the program in <a href="#Exercise-242-_00281_0029">Exercise 242 (1)</a> solves the puzzle in time T.
</p>
<p><strong>Solution</strong>
</p>
<p>Q(k): number of solutions of board size k
</p>
<p>T(k): number of steps required to calculate Q(k)
</p>
<p>original approach: T(k) = T(k-1) + k * Q(k-1)
</p>
<p>T(0) = 1
</p>
<p>louis&rsquo;s approach: T(k) = k * (T(k-1) + Q(k-1)) = k * T(k-1) + k * Q(k-1)
</p>
<p>T(0) = 1
</p></li></ol>

<hr>
<span id="Example-A-Picture-Language"></span><div class="header">
<p>
Previous: <a href="#Sequences-as-Conventional-Interfaces" accesskey="p" rel="prev">Sequences as Conventional Interfaces</a>, Up: <a href="#Hierarchical-Data-and-the-Closure-Property" accesskey="u" rel="up">Hierarchical Data and the Closure Property</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Example-A-Picture-Language-1"></span><h4 class="subsection">2.2.4 Example A Picture Language</h4>

<ul>
<li> What is crucial to the ability to create complex structures while using only a few operations?

<p>The closure of our data under the means of combination.
</p></li></ul>


<div class="float"><span id="square_002dlimit"></span>
<div class="example">
<pre class="example">(define (right-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (right-split painter (- n 1))))
        (beside painter
                (below smaller smaller)))))
(define (corner-split painter n)
  (if (= n 0)
      painter
      (let ((up (up-split painter (- n 1)))
            (right (right-split painter (- n 1))))
        (let ((top-left (beside up up))
              (bottom-right (below right
                                   right))
              (corner (corner-split painter (- n 1))))
          (beside (below painter top-left)
                  (below bottom-right
                         corner))))))
(define (square-limit painter n)
  (let ((quarter (corner-split painter n)))
    (let ((half (beside (flip-horiz quarter)
                        quarter)))
      (below (flip-vert half) half))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.56: </strong>square-limit</p></div></div>
<ol>
<li> Exercise 2.44


<span id="Exercise-244-_00281_0029"></span><span id="index-2_002e44-up_002dsplit"></span>

<p>Define the procedure <code>up-split</code> used by <code>corner-split</code>. It is similar to <code>right-split</code>, except that it switches the roles of below and beside.
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">+----+----+
|    |    |
| n-1| n-1|
+----+----+
|         |
|         |
+---------+
</pre></div>

<div class="float"><span id="exercise_002d2_002d44"></span>
<div class="example">
<pre class="example">(define (up-split painter n)
  (if (= n 0)
      painter
      (let ((smaller (up-split painter (- n 1))))
        (below (beside smaller smaller)
               painter))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.57: </strong>exercise-2-44</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;square-limit&gt;&gt;
&lt;&lt;exercise-2-44&gt;&gt;
(paint (up-split einstein 4))
</pre></div>

<img src="./images/exercise-2-44.png" alt="./images/exercise-2-44">

</li><li> Higher-order operations


<div class="float"><span id="square_002dof_002dfour"></span>
<div class="example">
<pre class="example">(define (square-of-four tl tr bl br)
  (lambda (painter)
    (let ((top (beside (tl painter)
                       (tr painter)))
          (bottom (beside (bl painter)
                          (br painter))))
      (below bottom top))))
(define (square-limit painter n)
  (let ((combine4
         (square-of-four flip-horiz
                         identity
                         rotate180
                         flip-vert)))
    (combine4 (corner-split painter n))))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.58: </strong>square-of-four</p></div></div>
</li><li> Exercise 2.45


<span id="Exercise-245-_00281_0029"></span><span id="index-2_002e45-general-split"></span>

<p><code>Right-split</code> and <code>up-split</code> can be expressed as instances of a general splitting operation. Define a procedure split with the property that evaluating
</p><div class="float"><span id="exercise_002d2_002d45_002dq"></span>
<div class="example">
<pre class="example">(define right-split (split beside below))
(define up-split (split below beside))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.59: </strong>exercise-2-45-q</p></div></div><p>produces procedures <code>right-split</code> and <code>up-split</code> with the same behaviors as the ones already defined.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d45"></span>
<div class="example">
<pre class="example">(define (split outer inner)
  (define (do-split painter n)
    (if (= n 0)
        painter
        (let ((smaller
               (do-split painter (- n 1))))
          (outer painter
                 (inner smaller smaller)))))
  do-split)
</pre></div>

<div class="float-caption"><p><strong>Listing 2.60: </strong>exercise-2-45</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;pict&gt;&gt;
&lt;&lt;exercise-2-45&gt;&gt;
&lt;&lt;exercise-2-45-q&gt;&gt;
(paint (right-split einstein 2))
(paint (up-split einstein 2))
</pre></div>

<img src="./images/exercise-2-45-1.png" alt="./images/exercise-2-45-1">

<img src="./images/exercise-2-45-2.png" alt="./images/exercise-2-45-2">

</li><li> Frames


<p>origin + transform \( \cdot \) v = v in frame
</p>
</li><li> Exercise 2.46


<span id="Exercise-246-_00281_0029"></span><span id="index-2_002e46-vect-constructor-and-selector"></span>

<p>A two-dimensional vector v running from the origin to a point can be represented as a pair consisting of an x-coordinate and a y-coordinate. Implement a data abstraction for vectors by giving a constructor make-vect and corresponding selectors xcor-vect and ycor-vect. In terms of your selectors and constructor, implement procedures add-vect, sub-vect, and scale-vect that perform the operations vector addition, vector subtraction, and multiplying a vector by a scalar:
</p>
<p>\begin{align*}
       (x_1 ,y_1 ) + (x_2 ,y_2 ) &amp;= (x_1 + x_2 ,y_1 + y_2 ), \\
       (x_1 ,y_1 ) − (x_2 ,y_2 ) &amp;= (x_1 − x_2 ,y_1 − y_2 ), \\
       s \cdot (x,y) &amp;= (sx, sy).
     \end{align*}
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d2_002d46"></span>
<div class="example">
<pre class="example">(define (make-vect x y) (list x y))
(define (xcor-vect v) (car v))
(define (ycor-vect v) (cadr v))
(define (add-vect v1 v2) (map + v1 v2))
(define (sub-vect v1 v2) (map - v1 v2))
(define (scale-vect s v) (map (lambda (cor) (* s cor)) v))
</pre></div>

<div class="float-caption"><p><strong>Listing 2.61: </strong>exercise-2-46</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;exercise-2-46&gt;&gt;
(define a (make-vect 1 2))
(define b (make-vect 3 4))
(p (xcor-vect a))
(p (ycor-vect b))
(p (add-vect a b))
(p (sub-vect a b))
(p (scale-vect 3 a))
</pre></div>

<div class="example">
<pre class="example">

1
4
(4 6)
(-2 -2)
(3 6)
</pre></div>

</li><li> Exercise 2.47


<span id="Exercise-247-_00281_0029"></span><span id="index-2_002e47-frame-constructor-and-selector"></span>

<p>Here are two possible constructors for frames:
</p><div class="example">
<pre class="example">(define (make-frame origin edge1 edge2)
(list origin edge1 edge2))

(define (make-frame origin edge1 edge2)
(cons origin (cons edge1 edge2)))
</pre></div>
<p>For each constructor supply the appropriate selectors to produce an implementation for frames.
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">(define (origin-frame f) (car f))
(define (edge1-frame f) (cadr f))
(define (edge2-frame f) (caddr f))

(define (origin-frame f) (car f))
(define (edge1-frame f) (cadr f))
(define (edge2-frame f) (cddr f))
</pre></div>

</li><li> Painters

</li></ol>

<hr>
<span id="Computing-with-Register-Machines"></span><div class="header">
<p>
Next: <a href="#Foreward" accesskey="n" rel="next">Foreward</a>, Previous: <a href="#Building-Abstractions-with-Data" accesskey="p" rel="prev">Building Abstractions with Data</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Computing-with-Register-Machines-1"></span><h2 class="chapter">3 Computing with Register Machines</h2>

<p>To explain the meanings of these procedures, we used a succession of models of evaluation:
</p><ul>
<li> the substitution model of Chapter 1,
</li><li> the environment model of Chapter 3,
</li><li> and the metacircular evaluator of Chapter 4.
</li></ul>


<p>Our examination of the metacircular evaluator, in particular, dispelled much of the mystery of how Lisp-like languages are interpreted.
</p>
<p>it fails to elucidate the mechanisms of control in a Lisp system. For instance, the evaluator does not explain how the evaluation of a subexpression manages to return a value to the expression that uses this value, nor does the evaluator explain how some recursive procedures generate iterative processes (that is, are evaluated using constant space) whereas other recursive procedures generate recursive processes.
</p>
<p>These questions remain unanswered because the metacircular evaluator is itself a Lisp program and hence inherits the control structure of the underlying Lisp system. In order to provide a more complete description of the control structure of the Lisp evaluator, we must work at a more primitive level than Lisp itself.
</p>
<p>or register machine, sequentially executes instructions that manipulate the contents of a fixed set of storage elements called registers. A typical register-machine instruction applies a primitive operation to the contents of some registers and assigns the result to another register.
</p>
<p>we will approach our task from the perspective of a hardware architect rather than that of a machine-language computer programmer.
</p>
<p>In designing register machines, we will develop mechanisms for implementing important programming constructs such as recursion. We will also present a language for describing designs for register machines. In 5.2 we will implement a Lisp program that uses these descriptions to simulate the machines we design.
</p>
<p>we will also use the memory operations car, cdr, and cons, which require an elaborate storage-allocation mechanism. In 5.3 we study their implementation in terms of more elementary operations.
</p>
<p>design a machine that carries out the algorithm described by the metacircular evaluator of 4.1.
</p>
<p>This will fill in the gap in our understanding of how Scheme expressions are interpreted, by providing an explicit model for the mechanisms of control in the evaluator.
</p>
<p>In 5.5 we will study a simple compiler that translates Scheme programs into sequences of instructions that can be executed directly with the registers and operations of the evaluator register machine.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Designing-Register-Machines" accesskey="1">Designing Register Machines</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#A-Register_002dMachine-Simulator" accesskey="2">A Register-Machine Simulator</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Designing-Register-Machines"></span><div class="header">
<p>
Next: <a href="#A-Register_002dMachine-Simulator" accesskey="n" rel="next">A Register-Machine Simulator</a>, Up: <a href="#Computing-with-Register-Machines" accesskey="u" rel="up">Computing with Register Machines</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Designing-Register-Machines-1"></span><h3 class="section">3.1 Designing Register Machines</h3>

<p>To design a register machine, we must design its data paths (registers and operations) and the controller that sequences these operations.
</p>
<p>To illustrate the design of a simple register machine
</p>
<div class="example">
<pre class="example">(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
</pre></div>

<div class="float"><span id="screen_005fshot_005f2020_005f12_005f22_005fat_005f14_005f22_005f24_002dfig"></span>
<img src="./images/5-data-paths-for-a-gcd-machine.png" alt="./images/5-data-paths-for-a-gcd-machine">

<div class="float-caption"><p><strong>Figure 3.1: </strong>Data paths for a GCD machine.</p></div></div>
<p>In order for the data paths to actually compute GCDs, the buttons must be pushed in the correct sequence.
</p>
<div class="float"><span id="screen_005fshot_005f2020_005f12_005f22_005fat_005f14_005f49_005f15_002dfig"></span>
<img src="./images/5-controller-for-a-gcd-machine.png" alt="./images/5-controller-for-a-gcd-machine">

<div class="float-caption"><p><strong>Figure 3.2: </strong>Controller for a GCD machine.</p></div></div>
<span id="index-5_002e01"></span>
<span id="Exercise-51"></span><p><strong>Exercise 5.1:</strong> Design a register machine to compute factorials using the iterative algorithm specified by the following procedure. Draw data-path and controller diagrams for this machine.
</p><div class="example">
<pre class="example">(define (factorial n)
  (define (iter product counter)
    (if (&gt; counter n)
        product
        (iter (* counter product)
              (+ counter 1))))
  (iter 1 1))
</pre></div>

<p><strong>Solution</strong>
</p>
<img src="./omni-exports/exercise-5-1.png" alt="./omni-exports/exercise-5-1">

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#A-Language-for-Describing-Register-Machines" accesskey="1">A Language for Describing Register Machines</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Actions" accesskey="2">Actions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Abstraction-in-Machine-Design" accesskey="3">Abstraction in Machine Design</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Subroutines" accesskey="4">Subroutines</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-a-Stack-to-Implement-Recursion" accesskey="5">Using a Stack to Implement Recursion</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Instruction-Summary" accesskey="6">Instruction Summary</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="A-Language-for-Describing-Register-Machines"></span><div class="header">
<p>
Next: <a href="#Actions" accesskey="n" rel="next">Actions</a>, Up: <a href="#Designing-Register-Machines" accesskey="u" rel="up">Designing Register Machines</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="A-Language-for-Describing-Register-Machines-1"></span><h4 class="subsection">3.1.1 A Language for Describing Register Machines</h4>

<p>create a language that presents, in textual form, all the information given by the data-path and controller diagrams. We will start with a notation that directly mirrors the diagrams.
</p>
<p>We define the data paths of a machine by describing the registers and the operations.
</p>
<p>We define the data paths of a machine by describing the registers and the operations. To describe a register, we give it a name and specify the buttons that control assignment to it. We give each of these buttons a name and specify the source of the data that enters the register under the button’s control. (The source is a register, a constant, or an operation.) To describe an operation, we give it a name and specify its inputs (registers or constants).
</p>
<div class="example">
<pre class="example">(data-paths
 (registers
  ((name a)
   (buttons ((name a&lt;-b)
             (source (register b)))))
  ((name b)
   (buttons ((name b&lt;-t)
             (source (register t)))))
  ((name t)
   (buttons ((name t&lt;-r)
             (source (operation rem))))))
 (operations
  ((name rem)
   (inputs (register a) (register b)))
  ((name =)
   (inputs (register b) (constant 0)))))

(controller
 test-b                ; label
 (test =)            ; test
 (branch
  (label gcd-done))  ; conditional branch
 (t&lt;-r)              ; button push
 (a&lt;-b)              ; button push
 (b&lt;-t)              ; button push
 (goto
  (label test-b))    ; unconditional branch
 gcd-done)             ; label
</pre></div>

<div class="example">
<pre class="example">(controller
 test-b
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label test-b))
 gcd-done)
</pre></div>

<span id="index-5_002e02"></span>
<span id="Exercise-52"></span><p><strong>Exercise 5.2:</strong> Use the register-machine language to describe the iterative factorial machine of <a href="#Exercise-51">Exercise 5.1</a>.
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">(data-paths
 (registers
  ((name n))
  ((name p)
   (buttons ((name p&lt;-m)
             (source (operation mul)))))
  ((name c)
   (buttons ((name c&lt;-a)
             (source (operation add))))))
 (operations
  ((name mul)
   (inputs (register c) (register p)))
  ((name add)
   (inputs (register c) (constant 1)))
  ((name &gt;)
   (inputs (register c) (register n)))))

(controller
 test-c              ; label
 (test &gt;)            ; test
 (branch
  (label iter-done)) ; conditional branch
 (p&lt;-m)              ; button push
 (c&lt;-a)              ; button push
 (goto
  (label test-c))    ; unconditional branch
 iter-done)          ; label

(controller
 test-c
 (test (op &gt;) (reg c) (reg n))
 (branch (label iter-done))
 (assign p (op mul) (reg c) (reg p))
 (assign c (op add) (reg c) (const 1))
 (goto (label test-c))
 iter-done)
</pre></div>

<hr>
<span id="Actions"></span><div class="header">
<p>
Next: <a href="#Abstraction-in-Machine-Design" accesskey="n" rel="next">Abstraction in Machine Design</a>, Previous: <a href="#A-Language-for-Describing-Register-Machines" accesskey="p" rel="prev">A Language for Describing Register Machines</a>, Up: <a href="#Designing-Register-Machines" accesskey="u" rel="up">Designing Register Machines</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Actions-1"></span><h4 class="subsection">3.1.2 Actions</h4>

<p>modify the GCD machine so that we can type in the numbers whose GCD we want and get the answer printed at our terminal.
</p>
<p>We will not discuss how to make a machine that can read and print, but will assume (as we do when we use read and display in Scheme) that they are available as primitive operations.
</p>
<p>Read is like the operations we have been using in that it produces a value that can be stored in a register. But read does not take inputs from any registers; its value depends on something that happens outside the parts of the machine we are designing.
</p>
<p>Though it has an effect, this effect is not on a part of the machine we are designing. We will refer to this kind of operation as an action.
</p>
<p>To make a controller push an action button we use a new kind of instruction called perform.
</p>
<p>the action of printing the contents of register a is represented in a controller sequence by the instruction
</p>
<div class="example">
<pre class="example">;; It does not produce an output value to be stored in a
;; register
(perform (op print) (reg a))

;; Different from rem that assigns to register t the value
;; of the rem operation on the contents of registers a and b
(assign t (op rem) (reg a) (reg b))
</pre></div>

<div class="float">
<img src="./images/5-reads-inputs-and-prints-results.png" alt="./images/5-reads-inputs-and-prints-results">

<div class="float-caption"><p><strong>Figure: </strong>A GCD machine that reads inputs and prints results.</p></div></div>
<div class="example">
<pre class="example">(controller
 gcd-loop
 (assign a (op read))
 (assign b (op read))
 test-b
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label test-b))
 gcd-done
 (perform (op print) (reg a))
 (goto (label gcd-loop)))
</pre></div>

<hr>
<span id="Abstraction-in-Machine-Design"></span><div class="header">
<p>
Next: <a href="#Subroutines" accesskey="n" rel="next">Subroutines</a>, Previous: <a href="#Actions" accesskey="p" rel="prev">Actions</a>, Up: <a href="#Designing-Register-Machines" accesskey="u" rel="up">Designing Register Machines</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Abstraction-in-Machine-Design-1"></span><h4 class="subsection">3.1.3 Abstraction in Machine Design</h4>

<p>We will often define a machine to include “primitive” operations that are actually very complex. The fact that we have swept a lot of complexity under the rug, however, does not mean that a machine design is unrealistic. We can always replace the complex “primitives” by simpler primitive operations.
</p>
<p>write a Scheme procedure that finds remainders in this way:
</p>
<div class="example">
<pre class="example">(define (remainder n d)
  (if (&lt; n d) n (remainder (- n d) d)))
</pre></div>

<div class="float">
<img src="./images/5-elaborated-gcd-machine.png" alt="./images/5-elaborated-gcd-machine">

<div class="float-caption"><p><strong>Figure: </strong>Data paths and controller for the elaborated GCD machine.</p></div></div>
<div class="example">
<pre class="example">(assign t (op rem) (reg a) (reg b))
</pre></div>

<p>in the GCD controller definition is replaced by a sequence of instructions that contains a loop
</p>
<div class="example">
<pre class="example">(controller
 test-b
   (test (op =) (reg b) (const 0))
   (branch (label gcd-done))
   (assign t (reg a))
 rem-loop
   (test (op &lt;) (reg t) (reg b))
   (branch (label rem-done))
   (assign t (op -) (reg t) (reg b))
   (goto (label rem-loop))
 rem-done
   (assign a (reg b))
   (assign b (reg t))
   (goto (label test-b))
 gcd-done)
</pre></div>

<span id="Exercise-53"></span><span id="index-5_002e03"></span>
<p><strong>Exercise 5.3:</strong> Design a machine to compute square roots using Newton’s method, as described in <a href="#Example-Square-Roots-by-Newton_0027s-Method">Example Square Roots by Newton's Method</a>:
</p>
<div class="example">
<pre class="example">(define (sqrt x)
  (define (good-enough? guess)
    (&lt; (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))
</pre></div>

<p>Begin by assuming that <code>good-enough?</code> and improve operations are available as primitives. Then show how to expand these in terms of arithmetic operations. Describe each version of the sqrt machine design by drawing a data-path diagram and writing a controller definition in the register-machine language.
</p>
<p><strong>Solution</strong>
</p>
<img src="./omni-exports/exercise-5-3a.png" alt="./omni-exports/exercise-5-3a">

<div class="example">
<pre class="example">(controller
 test-gn
 (test (op good-enough?) (reg g))
 (branch (label iter-done))
 (assign g (op improve) (reg g))
 (goto (label test-gn))
 iter-done)
</pre></div>

<img src="./omni-exports/exercise-5-3b.png" alt="./omni-exports/exercise-5-3b">

<div class="example">
<pre class="example">(controller
 good-enough
 (assign (reg t) (reg g))
 (assign (reg t) (op square) (reg t))
 (assign (reg t) (op sub) (reg t) (reg x))
 (test (op &lt;) (reg t) (const 0.001))
 (branch (label iter-done))
 (assign (reg t) (op div) (reg x) (reg t))
 (assign (reg g) (op average) (reg g) (reg t))
 (goto (label good-enough))
 iter-done)
</pre></div>

<hr>
<span id="Subroutines"></span><div class="header">
<p>
Next: <a href="#Using-a-Stack-to-Implement-Recursion" accesskey="n" rel="next">Using a Stack to Implement Recursion</a>, Previous: <a href="#Abstraction-in-Machine-Design" accesskey="p" rel="prev">Abstraction in Machine Design</a>, Up: <a href="#Designing-Register-Machines" accesskey="u" rel="up">Designing Register Machines</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Subroutines-1"></span><h4 class="subsection">3.1.4 Subroutines</h4>

<p>A more powerful method for implementing subroutines is to have the continue register hold the label of the entry point in the controller sequence at which execution should continue when the subroutine is finished.
</p>
<p>There must be a way to assign to a register a label in the controller sequence in such a way that this value can be fetched from the register and used to continue execution at the designated entry point.
</p>
<p>To reflect this ability, we will extend the assign instruction of the register-machine language to allow a register to be assigned as value a label from the controller sequence (as a special kind of constant).
</p>
<p>We will also extend the goto instruction to allow execution to continue at the entry point described by the contents of a register rather than only at an entry point described by a constant label.
</p>
<div class="example">
<pre class="example">gcd
 (test (op =) (reg b) (const 0))
 (branch (label gcd-done))
 (assign t (op rem) (reg a) (reg b))
 (assign a (reg b))
 (assign b (reg t))
 (goto (label gcd))
gcd-done
 (goto (reg continue))
  …
;; Before calling gcd,
;; we assign to continue the label
;; to which gcd should return.
 (assign continue (label after-gcd-1))
 (goto (label gcd))
after-gcd-1
  …
;; Here is the second call to gcd,
;; with a different continuation.
 (assign continue (label after-gcd-2))
 (goto (label gcd))
after-gcd-2
</pre></div>

<p>Sharing is more economical, but we must be careful if we have a subroutine (sub1) that calls another subroutine (sub2).
</p>
<hr>
<span id="Using-a-Stack-to-Implement-Recursion"></span><div class="header">
<p>
Next: <a href="#Instruction-Summary" accesskey="n" rel="next">Instruction Summary</a>, Previous: <a href="#Subroutines" accesskey="p" rel="prev">Subroutines</a>, Up: <a href="#Designing-Register-Machines" accesskey="u" rel="up">Designing Register Machines</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Using-a-Stack-to-Implement-Recursion-1"></span><h4 class="subsection">3.1.5 Using a Stack to Implement Recursion</h4>

<p>With the ideas illustrated so far, we can implement any iterative process by specifying a register machine that has a register corresponding to each state variable of the process. The machine repeatedly executes a controller loop, changing the contents of the registers, until some termination condition is satisfied. At each point in the controller sequence, the state of the machine (representing the state of the iterative process) is completely determined by the contents of the registers (the values of the state variables).
</p>
<p>Implementing recursive processes, however, requires an additional mechanism.
</p>
<p>But there is an important difference between the gcd procedure, which reduces the original computation to a new GCD computation, and factorial, which requires computing another factorial as a subproblem.
</p>
<img src="./images/5-recursive-factorial-machine.png" alt="./images/5-recursive-factorial-machine">

<div class="float"><span id="recursive_002dfactorial_002dmachine"></span>
<div class="example">
<pre class="example">(controller
   (assign continue (label fact-done))   ; set up final return address
 fact-loop
   (test (op =) (reg n) (const 1))
   (branch (label base-case))
   (save continue)                       ; Set up for the recursive call
   (save n)                              ; by saving n and continue.
   (assign n (op -) (reg n) (const 1))   ; Set up continue so that the
   (assign continue (label after-fact))  ; computation will continue
   (goto (label fact-loop))              ; at after-fact when the
 after-fact                              ; subroutine returns.
   (restore n)
   (restore continue)
   (assign val (op *) (reg n) (reg val)) ; val now contains n(n - 1)!
   (goto (reg continue))                 ; return to caller
 base-case
   (assign val (const 1))                ; base case: 1! = 1
   (goto (reg continue))                 ; return to caller
 fact-done)
</pre></div>

<div class="float-caption"><p><strong>Listing 3.1: </strong>A recursive factorial machine.</p></div></div>
<ol>
<li> A double recursion


<div class="example">
<pre class="example">(define (fib n)
  (if (&lt; n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
</pre></div>

<div class="float"><span id="compute_002dfibonacci_002dnumbers"></span>
<div class="example">
<pre class="example">(controller
   (assign continue (label fib-done))
 fib-loop
   (test (op &lt;) (reg n) (const 2))
   (branch (label immediate-answer))
   ;; set up to compute Fib(n − 1)
   (save continue)
   (assign continue (label afterfib-n-1))
   (save n)           ; save old value of n
   (assign n
           (op -)
           (reg n)
           (const 1)) ; clobber n to n-1
   (goto
    (label fib-loop)) ; perform recursive call
 afterfib-n-1 ; upon return, val contains Fib(n − 1)
   (restore n)
   (restore continue)
   ;; set up to compute Fib(n − 2)
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)         ; save Fib(n − 1)
   (goto (label fib-loop))
 afterfib-n-2 ; upon return, val contains Fib(n − 2)
   (assign n
           (reg val)) ; n now contains Fib(n − 2)
   (restore val)      ; val now contains Fib(n − 1)
   (restore continue)
   (assign val        ; Fib(n − 1) + Fib(n − 2)
           (op +)
           (reg val)
           (reg n))
   (goto              ; return to caller,
    (reg continue))   ; answer is in val
 immediate-answer
   (assign val
           (reg n))   ; base case: Fib(n) = n
   (goto (reg continue))
 fib-done)
</pre></div>

<div class="float-caption"><p><strong>Listing 3.2: </strong>Controller for a machine to compute Fibonacci numbers.</p></div></div>
<span id="index-5_002e04"></span>
<span id="Exercise-54"></span><p><strong>Exercise 5.4:</strong> Specify register machines that implement each of the following procedures. For each machine, write a controller instruction sequence and draw a diagram showing the data paths.
</p>
<ol>
<li> Recursive exponentiation:

<div class="example">
<pre class="example">(define (expt b n)
  (if (= n 0)
      1
      (* b (expt b (- n 1)))))
</pre></div>

</li><li> Iterative exponentiation:

<div class="example">
<pre class="example">(define (expt b n)
  (define (expt-iter counter product)
    (if (= counter 0)
        product
        (expt-iter (- counter 1)
                   (* b product))))
  (expt-iter n 1))
</pre></div>
</li></ol>


<p><strong>Solution</strong>
</p>
<img src="./omni-exports/exercise-5-4a.png" alt="./omni-exports/exercise-5-4a">

<div class="example">
<pre class="example">(controller
   (assign continue (label expt-done))
 expt-loop
   (test (op =) (reg n) (const 0))
   (branch (label base-case))
   (save continue)
   (assign n (op -) (reg n) (const 1))
   (assign continue (label after-expt))
   (goto (label expt-loop))
 after-expt
   (restore continue)
   (assign val (op *) (reg val) (reg b))
   (goto (reg continue))
 base-case
   (assign val (const 1))
   (goto (reg continue))
 expt-done)
</pre></div>

<img src="./omni-exports/exercise-5-4b.png" alt="./omni-exports/exercise-5-4b">

<div class="example">
<pre class="example">(controller
 test-c
   (test (reg c) (const 0))
   (branch (label iter-done))
   (assign (reg c) (op -) (reg c) (const 1))
   (assign (reg p) (op *) (reg b) (reg p))
   (goto (label test-c))
 iter-done)
</pre></div>

<span id="Exercise-55"></span><span id="index-5_002e05"></span>
<p><strong>Exercise 5.5:</strong> Hand-simulate the factorial and Fibonacci machines, using some nontrivial input (requiring execution of at least one recursive call). Show the contents of the stack at each significant point in the execution.
</p>
<p><strong>Solution</strong>
</p>
<img src="./omni-exports/exercise-5-5a.png" alt="./omni-exports/exercise-5-5a">

<img src="./omni-exports/exercise-5-5b.png" alt="./omni-exports/exercise-5-5b">

<div class="example">
<pre class="example">(controller
   (assign continue (label fib-done))     ; 1
 fib-loop
   (test (op &lt;) (reg n) (const 2))
   (branch (label immediate-answer))
   (save continue)                        ; 2 6
   (assign continue (label afterfib-n-1)) ; 3 7
   (save n)                               ; 4 8
   (assign n (op -) (reg n) (const 1))    ; 5 9
   (goto (label fib-loop))
 afterfib-n-1
   (restore n)                            ; 11 20
   (assign n (op -) (reg n) (const 2))    ; 12 21
   (assign continue (label afterfib-n-2)) ; 13 22
   (save val)                             ; 14 23
   (goto (label fib-loop))
 afterfib-n-2
   (assign n (reg val))                   ; 16 25
   (restore val)                          ; 17 26
   (restore continue)                     ; 18 27
   (assign val (op +) (reg val) (reg n))  ; 19 28
   (goto (reg continue))
 immediate-answer
   (assign val (reg n))                   ; 10 15 24
   (goto (reg continue))
 fib-done)
</pre></div>

<table>
<thead><tr><th>step</th><th>label</th><th>n</th><th>val</th><th>continue</th><th>stack</th></tr></thead>
<tr><td>1</td><td></td><td>3</td><td></td><td>done</td><td></td></tr>
<tr><td>2</td><td>loop</td><td>3</td><td></td><td>done</td><td>done</td></tr>
<tr><td>3</td><td></td><td>3</td><td></td><td>n-1</td><td>done</td></tr>
<tr><td>4</td><td></td><td>3</td><td></td><td>n-1</td><td>done n:3</td></tr>
<tr><td>5</td><td></td><td>2</td><td></td><td>n-1</td><td>done n:3</td></tr>
<tr><td>6</td><td>loop</td><td>2</td><td></td><td>n-1</td><td>done n:3 n-1</td></tr>
<tr><td>7</td><td></td><td>2</td><td></td><td>n-1</td><td>done n:3 n-1</td></tr>
<tr><td>8</td><td></td><td>2</td><td></td><td>n-1</td><td>done n:3 n-1 n:2</td></tr>
<tr><td>9</td><td></td><td>1</td><td></td><td>n-1</td><td>done n:3 n-1 n:2</td></tr>
<tr><td>10</td><td>im</td><td>1</td><td>1</td><td>n-1</td><td>done n:3 n-1 n:2</td></tr>
<tr><td>11</td><td>n-1</td><td>2</td><td>1</td><td>n-1</td><td>done n:3 n-1</td></tr>
<tr><td>12</td><td></td><td>0</td><td>1</td><td>n-1</td><td>done n:3 n-1</td></tr>
<tr><td>13</td><td></td><td>0</td><td>1</td><td>n-2</td><td>done n:3 n-1</td></tr>
<tr><td>14</td><td></td><td>0</td><td>1</td><td>n-2</td><td>done n:3 n-1 v:1</td></tr>
<tr><td>15</td><td>im</td><td>0</td><td>0</td><td>n-2</td><td>done n:3 n-1 v:1</td></tr>
<tr><td>16</td><td>n-2</td><td>0</td><td>0</td><td>n-2</td><td>done n:3 n-1 v:1</td></tr>
<tr><td>17</td><td></td><td>0</td><td>1</td><td>n-2</td><td>done n:3 n-1</td></tr>
<tr><td>18</td><td></td><td>0</td><td>1</td><td>n-1</td><td>done n:3</td></tr>
<tr><td>19</td><td></td><td>0</td><td>1</td><td>n-1</td><td>done n:3</td></tr>
<tr><td>20</td><td>n-1</td><td>3</td><td>1</td><td>n-1</td><td>done</td></tr>
<tr><td>21</td><td></td><td>1</td><td>1</td><td>n-1</td><td>done</td></tr>
<tr><td>22</td><td></td><td>1</td><td>1</td><td>n-2</td><td>done</td></tr>
<tr><td>23</td><td></td><td>1</td><td>1</td><td>n-2</td><td>done v:1</td></tr>
<tr><td>24</td><td>im</td><td>1</td><td>1</td><td>n-2</td><td>done v:1</td></tr>
<tr><td>25</td><td>n-2</td><td>1</td><td>1</td><td>n-2</td><td>done v:1</td></tr>
<tr><td>26</td><td></td><td>1</td><td>1</td><td>n-2</td><td>done</td></tr>
<tr><td>27</td><td></td><td>1</td><td>1</td><td>done</td><td></td></tr>
<tr><td>28</td><td></td><td>1</td><td>2</td><td>done</td><td></td></tr>
</table>

<span id="Exercise-56"></span><span id="index-5_002e06"></span>
<p><strong>Exercise 5.6</strong>: Ben Bitdiddle observes that the Fibonacci machine’s controller sequence has an extra save and an extra <code>restore</code>, which can be removed to make a faster machine. Where are these instructions?
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">afterfib-n-1 ; upon return, val contains Fib(n − 1)
   (restore n)
   ;; (restore continue) ; this can be removed
   ;; set up to compute Fib(n − 2)
   (assign n (op -) (reg n) (const 2))
   (save continue)
   (assign continue (label afterfib-n-2))
   (save val)         ; save Fib(n − 1)
   (goto (label fib-loop))
</pre></div>
</li></ol>

<hr>
<span id="Instruction-Summary"></span><div class="header">
<p>
Previous: <a href="#Using-a-Stack-to-Implement-Recursion" accesskey="p" rel="prev">Using a Stack to Implement Recursion</a>, Up: <a href="#Designing-Register-Machines" accesskey="u" rel="up">Designing Register Machines</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Instruction-Summary-1"></span><h4 class="subsection">3.1.6 Instruction Summary</h4>

<hr>
<span id="A-Register_002dMachine-Simulator"></span><div class="header">
<p>
Previous: <a href="#Designing-Register-Machines" accesskey="p" rel="prev">Designing Register Machines</a>, Up: <a href="#Computing-with-Register-Machines" accesskey="u" rel="up">Computing with Register Machines</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="A-Register_002dMachine-Simulator-1"></span><h3 class="section">3.2 A Register-Machine Simulator</h3>

<div class="float"><span id="gcd_002dmachine"></span>
<div class="example">
<pre class="example">(define gcd-machine
  (make-machine
   '(a b t)
   (list (list 'rem remainder) (list '= =))
   '(test-b
     (test (op =) (reg b) (const 0))
     (branch (label gcd-done))
     (assign t (op rem) (reg a) (reg b))
     (assign a (reg b)) (assign b (reg t))
     (goto (label test-b))
     gcd-done)))
</pre></div>

<div class="float-caption"><p><strong>Listing 3.3: </strong>gcd-machine</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;machine&gt;&gt;
&lt;&lt;assemble&gt;&gt;
&lt;&lt;execution-procedure&gt;&gt;
&lt;&lt;gcd-machine&gt;&gt;
(set-register-contents! gcd-machine 'a 12)
(set-register-contents! gcd-machine 'b 8)
(gcd-machine 'start)
(p (get-register-contents gcd-machine 'a))
</pre></div>

<div class="example">
<pre class="example">

4
</pre></div>


<span id="index-5_002e07"></span>
<span id="Exercise-57"></span><p><strong>Exercise 5.7:</strong> Use the simulator to test the machines you designed in <a href="#Exercise-54">Exercise 54</a>.
</p>
<p><strong>Solution</strong>
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#The-Machine-Model" accesskey="1">The Machine Model</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-Assembler" accesskey="2">The Assembler</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Generating-Execution-Procedures-for-Instructions" accesskey="3">Generating Execution Procedures for Instructions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Monitoring-Machine-Performance" accesskey="4">Monitoring Machine Performance</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="The-Machine-Model"></span><div class="header">
<p>
Next: <a href="#The-Assembler" accesskey="n" rel="next">The Assembler</a>, Up: <a href="#A-Register_002dMachine-Simulator" accesskey="u" rel="up">A Register-Machine Simulator</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-Machine-Model-1"></span><h4 class="subsection">3.2.1 The Machine Model</h4>

<img src="./omni-exports/5-make-machine.png" alt="./omni-exports/5-make-machine">

<div class="float"><span id="machine"></span>
<div class="example">
<pre class="example">(define (make-machine register-names ops controller-text)
  (let ((machine (make-new-machine)))
    (for-each (lambda (register-name)
                ((machine 'allocate-register)
                 register-name))
              register-names)
    ((machine 'install-operations) ops)
    ((machine 'install-instruction-sequence)
     (assemble controller-text machine))
    machine))

;;; Register
(define (make-register name)
  (let ((contents '*unassigned*))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
            ((eq? message 'set)
             (lambda (value)
               (set! contents value)))
            (else
             (error &quot;Unknown request: REGISTER&quot; message))))
    dispatch))

(define (get-contents register) (register 'get))
(define (set-contents! register value) ((register 'set) value))

;;; Stack
(define (make-stack)
  (let ((s '()))
    (define (push x)
      (set! s (cons x s)))
    (define (pop)
      (if (null? s)
          (error &quot;Empty stack: POP&quot;)
          (let ((top (car s)))
            (set! s (cdr s))
            top)))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize)
             (initialize))
            (else
             (error &quot;Unknown request: STACK&quot; message))))
    dispatch))

(define (pop stack) (stack 'pop))
(define (push stack value) ((stack 'push) value))

;; +----------------------------------------
;; | stack:()
;; | the-instruction-sequence:()
;; | the-ops:(('initialize-stack λ))
;; | register-table:(('pc pc) ('flag flag))
;; |

;;; The basic machine
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc)
                 (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error &quot;Multiply defined register: &quot; name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error &quot;Unknown register:&quot; name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq)
                 (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register)
               allocate-register)
              ((eq? message 'get-register)
               lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops)
                 (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              ((eq? message 'debug)
               (list (list &quot;stack: &quot;stack)
                     (list &quot;ins: &quot; the-instruction-sequence)
                     (list &quot;ops: &quot; the-ops)
                     (list &quot;register table: &quot;register-table)))
              (else (error &quot;Unknown request: MACHINE&quot; message))))
      dispatch)))

;;; interface
(define (start machine)
  (machine 'start))

(define (get-register-contents
         machine register-name)
  (get-contents
   (get-register machine register-name)))

(define (set-register-contents!
         machine register-name value)
  (set-contents!
   (get-register machine register-name)
   value)
  'done)

(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))
</pre></div>

<div class="float-caption"><p><strong>Listing 3.4: </strong>machine</p></div></div>
<hr>
<span id="The-Assembler"></span><div class="header">
<p>
Next: <a href="#Generating-Execution-Procedures-for-Instructions" accesskey="n" rel="next">Generating Execution Procedures for Instructions</a>, Previous: <a href="#The-Machine-Model" accesskey="p" rel="prev">The Machine Model</a>, Up: <a href="#A-Register_002dMachine-Simulator" accesskey="u" rel="up">A Register-Machine Simulator</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-Assembler-1"></span><h4 class="subsection">3.2.2 The Assembler</h4>

<div class="float"><span id="assemble"></span>
<div class="example">
<pre class="example">(define (assemble controller-text machine)
  (extract-labels
   controller-text
   (lambda (insts labels)
     (update-insts! insts labels machine)
     insts)))

;; build the initial instruction list and label table from the
;; supplied controller text.
(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels
       (cdr text)
       (lambda (insts labels)
         (let ((next-inst (car text)))
           (if (symbol? next-inst)
               (receive
                   insts
                   (cons (make-label-entry next-inst insts)
                         labels))
               (receive
                   (cons (make-instruction next-inst)
                         insts)
                   labels)))))))

(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
        (flag (get-register machine 'flag))
        (stack (machine 'stack))
        (ops (machine 'operations)))
    (for-each
     (lambda (inst)
       (set-instruction-execution-proc!
        inst
        (make-execution-procedure
         (instruction-text inst)
         labels machine pc flag stack ops)))
     insts)))

(define (make-instruction text)
  (cons text '()))
(define (instruction-text inst)
  (car inst))
(define (instruction-execution-proc inst)
  (cdr inst))
(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))

(define (make-label-entry label-name insts)
  (cons label-name insts))

(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
        (cdr val)
        (error &quot;Undefined label: ASSEMBLE&quot;
               label-name))))
</pre></div>

<div class="float-caption"><p><strong>Listing 3.5: </strong>assemble</p></div></div>
<span id="index-5_002e08"></span>
<span id="Exercise-58"></span><p>Exercise 5.8: The following register-machine code is ambiguous, because the label here is defined more than once:
</p>
<div class="example">
<pre class="example">start
  (goto (label here))
here
  (assign a (const 3))
  (goto (label there))
here
  (assign a (const 4))
  (goto (label there))
there
</pre></div>

<p>With the simulator as written, what will the contents of register <code>a</code> be when control reaches there? Modify the extract-labels procedure so that the assembler will signal an error if the same label name is used to indicate two different locations.
</p>
<p><strong>Solution</strong>
</p>
<p>Contents of register <code>a</code> will be 3.
</p>
<div class="example">
<pre class="example">(define (extract-labels text receive)
  (if (null? text)
      (receive '() '())
      (extract-labels
       (cdr text)
       (lambda (insts labels)
         (let ((next-inst (car text)))
           (if (symbol? next-inst)
               (if (assoc next-inst labels)
                   (error &quot;Duplicated label: ASSEMBLE&quot;
                          next-inst)
                   (receive
                       insts
                       (cons (make-label-entry next-inst insts)
                             labels)))
               (receive
                   (cons (make-instruction next-inst)
                         insts)
                   labels)))))))
</pre></div>

<hr>
<span id="Generating-Execution-Procedures-for-Instructions"></span><div class="header">
<p>
Next: <a href="#Monitoring-Machine-Performance" accesskey="n" rel="next">Monitoring Machine Performance</a>, Previous: <a href="#The-Assembler" accesskey="p" rel="prev">The Assembler</a>, Up: <a href="#A-Register_002dMachine-Simulator" accesskey="u" rel="up">A Register-Machine Simulator</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Generating-Execution-Procedures-for-Instructions-1"></span><h4 class="subsection">3.2.3 Generating Execution Procedures for Instructions</h4>

<div class="float"><span id="execution_002dprocedure"></span>
<div class="example">
<pre class="example">(define (make-execution-procedure
         inst labels machine pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign
          inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test
          inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch
          inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform
          inst machine labels ops pc))
        (else (error &quot;Unknown instruction
                      type: ASSEMBLE&quot;
                     inst))))

;;; Assign instructions

(define (make-assign
         inst machine labels operations pc)
  (let ((target
         (get-register
          machine
          (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp
                machine
                labels
                operations)
               (make-primitive-exp
                (car value-exp)
                machine
                labels))))
      (lambda ()   ; execution procedure for assign
        (set-contents! target (value-proc))
        (advance-pc pc)))))

(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))
(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))

(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))

;;; Test, branch, and goto instructions

(define (make-test
         inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition
                machine
                labels
                operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error &quot;Bad TEST instruction:
                ASSEMBLE&quot; inst))))

(define (test-condition test-instruction)
  (cdr test-instruction))

(define (make-branch
         inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label
                labels
                (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error &quot;Bad BRANCH instruction:
                ASSEMBLE&quot;
               inst))))

(define (branch-dest branch-instruction)
  (cadr branch-instruction))

(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label
                   labels
                   (label-exp-label dest))))
             (lambda ()
               (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (get-register
                   machine
                   (register-exp-reg dest))))
             (lambda ()
               (set-contents!
                pc
                (get-contents reg)))))
          (else (error &quot;Bad GOTO instruction:
                        ASSEMBLE&quot;
                       inst)))))

(define (goto-dest goto-instruction)
  (cadr goto-instruction))

;;; Other instructions

(define (make-save inst machine stack pc)
  (let ((reg (get-register
              machine
              (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let ((reg (get-register
              machine
              (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))
      (advance-pc pc))))

(define (stack-inst-reg-name
         stack-instruction)
  (cadr stack-instruction))

(define (make-perform
         inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action
                machine
                labels
                operations)))
          (lambda ()
            (action-proc)
            (advance-pc pc)))
        (error &quot;Bad PERFORM instruction:
                ASSEMBLE&quot;
               inst))))

(define (perform-action inst) (cdr inst))

;;; Execution procedures for subexpressions

(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label
                 labels
                 (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register
                   machine
                   (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else (error &quot;Unknown expression type:
                      ASSEMBLE&quot;
                     exp))))

(define (register-exp? exp)
  (tagged-list? exp 'reg))
(define (register-exp-reg exp)
  (cadr exp))
(define (constant-exp? exp)
  (tagged-list? exp 'const))
(define (constant-exp-value exp)
  (cadr exp))
(define (label-exp? exp)
  (tagged-list? exp 'label))
(define (label-exp-label exp)
  (cadr exp))

(define (make-operation-exp
         exp machine labels operations)
  (let ((op (lookup-prim
             (operation-exp-op exp)
             operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp
                 e machine labels))
              (operation-exp-operands exp))))
    (lambda () (apply op (map (lambda (p) (p))
                              aprocs)))))

(define (operation-exp? exp)
  (and (pair? exp)
       (tagged-list? (car exp) 'op)))
(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))
(define (operation-exp-operands operation-exp)
  (cdr operation-exp))

(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error &quot;Unknown operation: ASSEMBLE&quot;
               symbol))))
</pre></div>

<div class="float-caption"><p><strong>Listing 3.6: </strong>execution-procedure</p></div></div>
<span id="index-5_002e09"></span>
<span id="Exercise-59"></span><p><strong>Exercise 5.9:</strong> The treatment of machine operations above permits them to operate on labels as well as on constants and the contents of registers. Modify the expression-processing procedures to enforce the condition that operations can be used only with registers and constants.
</p>
<p><strong>Solution</strong>
</p>
<div class="example">
<pre class="example">(define (make-operation-exp
         exp machine labels operations)
  (let ((op (lookup-prim
             (operation-exp-op exp)
             operations))
        (aprocs
         (map (lambda (e)
                (if (or (register-exp? e)
                        (constant-exp? e))
                    (make-primitive-exp e machine labels)
                    (error &quot;Only registers and constants
                            are permitted: ASSEMBLE&quot;
                           e))
              (operation-exp-operands exp))))
    (lambda () (apply op (map (lambda (p) (p))
                              aprocs)))))
</pre></div>

<span id="index-5_002e10"></span>
<span id="Exercise-510"></span><p><strong>Exercise 5.10:</strong> Design a new syntax for register-machine instructions and modify the simulator to use your new syntax. Can you implement your new syntax without changing any part of the simulator except the syntax procedures in this section?
</p>
<p><strong>Solution</strong>
</p>
<span id="index-5_002e11"></span>
<span id="Exercise-511"></span><p>Exercise 5.11: When we introduced <code>save</code> and <code>restore</code> in <a href="#Using-a-Stack-to-Implement-Recursion">Using a Stack to Implement Recursion</a>, we didn’t specify what would happen if you tried to restore a register that was not the last one saved, as in the sequence
</p>
<div class="example">
<pre class="example">(save y)
(save x)
(restore y)
</pre></div>

<p>There are several reasonable possibilities for the meaning of <code>restore</code>:
</p>
<ol>
<li> <code>(restore y)</code> puts into <code>y</code> the last value saved on the stack, regardless of what register that value came from. This is the way our simulator behaves. Show how to take advantage of this behavior to eliminate one instruction from the Fibonacci machine of <a href="#Using-a-Stack-to-Implement-Recursion">Using a Stack to Implement Recursion</a> (<a href="#compute_002dfibonacci_002dnumbers">Listing 3.2</a>).
</li><li> <code>(restore y)</code> puts into <code>y</code> the last value saved on the stack, but only if that value was saved from y; otherwise, it signals an error. Modify the simulator to behave this way. You will have to change save to put the register name on the stack along with the value.
</li><li> <code>(restore y)</code> puts into <code>y</code> the last value saved from <code>y</code> regardless of what other registers were saved after <code>y</code> and not restored. Modify the simulator to behave this way. You will have to associate a separate stack with each register. You should make the <code>initialize-stack</code> operation initialize all the register stacks.
</li></ol>


<p><strong>Solution</strong>
</p>
<ol>
<li> See <a href="#Exercise-55">Exercise 55</a> solution.

<div class="example">
<pre class="example">afterfib-n-2
  ;; (assign n (reg val))
  ;; (restore val)
  (restore n)
  (restore continue)
</pre></div>

</li><li> <div class="example">
<pre class="example">(define (make-save inst machine stack pc)
  (let ((reg-name (stack-inst-reg-name inst)))
    (let ((reg (get-register machine reg-name)))
      (lambda ()
        (push stack (cons reg-name (get-contents reg)))
        (advance-pc pc)))))

(define (make-restore inst machine stack pc)
  (let ((reg-name (stack-inst-reg-name inst)))
    (let ((reg (get-register machine reg-name)))
      (lambda ()
        (let ((x (pop stack)))
          (if (eq? (car x) reg-name)
              (set-contents! reg (cdr x))
              (error &quot;Value wasn't saved from&quot;
                     reg-name v))
          (advance-pc pc))))))

</pre></div>

</li><li> <div class="example">
<pre class="example">(define (make-stack-table)
  (let ((st '()))
    (define (push k x)
      (let (s (assoc k st))
        (if s
            ((s 'push) x)
            (set! st (cons (list k (((make-stack) 'push) x))
                           st)))))
    (define (pop k)
      (let (s (assoc k st))
        (if s
            (if (null? s)
                (error &quot;Empty stack: POP&quot;)
                (let ((top (car s)))
                  (set! s (cdr s))
                  top))
            (error &quot;No such key: POP&quot;))))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond ((eq? message 'push) push)
            ((eq? message 'pop) (pop))
            ((eq? message 'initialize)
             (initialize))
            (else
             (error &quot;Unknown request: STACK&quot;
                    message))))
    dispatch))

(define (pop-st stack key) ((stack 'pop) key))
(define (push-st stack key value) ((stack 'push) key value))

(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack-table))
        (the-instruction-sequence '()))
    (let ((the-ops
           (list
            (list 'initialize-stack
                  (lambda ()
                    (stack 'initialize)))))
          (register-table
           (list (list 'pc pc)
                 (list 'flag flag)))
          (stack-table '())
          (define (allocate-register name)
            (if (assoc name register-table)
                (error
                 &quot;Multiply defined register: &quot;
                 name)
                (set! register-table
                      (cons
                       (list name
                             (make-register name))
                       register-table)))
            'register-allocated)
          (define (lookup-register name)
            (let ((val
                   (assoc name register-table)))
              (if val
                  (cadr val)
                  (error &quot;Unknown register:&quot;
                         name))))
          (define (execute)
            (let ((insts (get-contents pc)))
              (if (null? insts)
                  'done
                  (begin
                    ((instruction-execution-proc
                      (car insts)))
                    (execute)))))
          (define (dispatch message)
            (cond ((eq? message 'start)
                   (set-contents!
                    pc
                    the-instruction-sequence)
                   (execute))
                  ((eq?
                    message
                    'install-instruction-sequence)
                   (lambda (seq)
                     (set!
                      the-instruction-sequence
                      seq)))
                  ((eq? message
                        'allocate-register)
                   allocate-register)
                  ((eq? message 'get-register)
                   lookup-register)
                  ((eq? message
                        'install-operations)
                   (lambda (ops)
                     (set! the-ops
                           (append the-ops ops))))
                  ((eq? message 'stack) stack)
                  ((eq? message 'operations)
                   the-ops)
                  (else (error &quot;Unknown request:
                            MACHINE&quot;
                               message))))
          dispatch)))
</pre></div>
</li></ol>


<span id="index-5_002e12"></span>
<span id="Exercise-512"></span><p><strong>Exercise 5.12:</strong> The simulator can be used to help determine the data paths required for implementing a machine with a given controller. Extend the assembler to store the following information in the machine model:
</p>
<ul>
<li> a list of all instructions, with duplicates removed, sorted by instruction type (<code>assign</code>, <code>goto</code>, and so on);
</li><li> a list (without duplicates) of the registers used to hold entry points (these are the registers referenced by <code>goto</code> instructions);
</li><li> a list (without duplicates) of the registers that are <code>saved</code> or <code>restored</code>;
</li><li> for each register, a list (without duplicates) of the sources from which it is assigned (for example, the sources for register <code>val</code> in the factorial machine of <a href="#recursive_002dfactorial_002dmachine">Listing 3.1</a> are <code>(const 1)</code> and <code>((op *) (reg n) (reg val))</code>).
</li></ul>


<p>Extend the message-passing interface to the machine to provide access to this new information. To test your analyzer, define the Fibonacci machine from <a href="#compute_002dfibonacci_002dnumbers">Listing 3.2</a> and examine the lists you constructed.
</p>
<p><strong>Solution</strong>
</p>
<div class="float"><span id="exercise_002d5_002d12"></span>
<div class="example">
<pre class="example">(define (unique-add seq x)
  (define (unique? seq)
    (cond ((null? seq) ture)
          ((eq? (car seq) x) false)
          (unique? (cdr seq))))
  (if (unique? seq)
      (cons x seq)
      seq))
(define (make-data-path)
  (let ((d (list 'instructions '())))
    (define (add-inst type inst)
      (let ((type-insts (assoc 'instructions d)))
        (if type-insts
            (let ((insts (assoc type type-insts)))
              (set! insts (unique-add insts inst)))
            (set! type-insts
                  (list (list type (list inst)))))))
    (lambda (message)
      (cond ((eq? message 'add-inst add-inst))
            ((eq? message 'instructions (assoc 'instructions d)))))))
(define (make-new-machine)
  (let ((pc (make-register 'pc))
        (flag (make-register 'flag))
        (stack (make-stack))
        (the-instruction-sequence '())
        (data-path (make-data-path)))
    (let ((the-ops
           (list (list 'initialize-stack
                       (lambda () (stack 'initialize)))))
          (register-table
           (list (list 'pc pc)
                 (list 'flag flag))))
      (define (allocate-register name)
        (if (assoc name register-table)
            (error &quot;Multiply defined register: &quot; name)
            (set! register-table
                  (cons (list name (make-register name))
                        register-table)))
        'register-allocated)
      (define (lookup-register name)
        (let ((val (assoc name register-table)))
          (if val
              (cadr val)
              (error &quot;Unknown register:&quot; name))))
      (define (execute)
        (let ((insts (get-contents pc)))
          (if (null? insts)
              'done
              (begin
                ((instruction-execution-proc (car insts)))
                (execute)))))
      (define (dispatch message)
        (cond ((eq? message 'start)
               (set-contents! pc the-instruction-sequence)
               (execute))
              ((eq? message 'install-instruction-sequence)
               (lambda (seq)
                 (set! the-instruction-sequence seq)))
              ((eq? message 'allocate-register)
               allocate-register)
              ((eq? message 'get-register)
               lookup-register)
              ((eq? message 'install-operations)
               (lambda (ops)
                 (set! the-ops (append the-ops ops))))
              ((eq? message 'stack) stack)
              ((eq? message 'operations) the-ops)
              ((eq? message 'data-path) data-path)
              (else (error &quot;Unknown request: MACHINE&quot; message))))
      dispatch)))

(define (make-assign
         inst machine labels operations pc)
  (((machine 'data-path) 'add-inst) 'assign inst)
  (let ((target
         (get-register
          machine
          (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp
                machine
                labels
                operations)
               (make-primitive-exp
                (car value-exp)
                machine
                labels))))
      (lambda ()   ; execution procedure for assign
        (set-contents! target (value-proc))
        (advance-pc pc)))))
</pre></div>

<div class="float-caption"><p><strong>Listing 3.7: </strong>exercise-5-12</p></div></div>
<div class="float"><span id="fib_002dmachine"></span>
<div class="example">
<pre class="example">(define insts
  '((assign continue (label fib-done))
    fib-loop
    (test (op &lt;) (reg n) (const 2))
    (branch (label immediate-answer))
    (save continue)
    (assign continue (label afterfib-n-1))
    (save n)
    (assign n (op -) (reg n) (const 1))
    (goto (label fib-loop))
    afterfib-n-1
    (restore n)
    (assign n (op -) (reg n) (const 2))
    (assign continue (label afterfib-n-2))
    (save val)
    (goto (label fib-loop))
    afterfib-n-2
    (assign n (reg val))
    (restore val)
    (restore continue)
    (assign val (op +) (reg val) (reg n))
    (goto (reg continue))
    immediate-answer
    (assign val (reg n))
    (goto (reg continue))
    fib-done))
  (define fib-machine
    (make-machine
     '(n val continue)
     (list (list '&lt; &lt;) (list '- -) (list '+ +))
     insts))
</pre></div>

<div class="float-caption"><p><strong>Listing 3.8: </strong>fib-machine</p></div></div>
<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;machine&gt;&gt;
&lt;&lt;assemble&gt;&gt;
&lt;&lt;execution-procedure&gt;&gt;
;; &lt;&lt;exercise-5-12&gt;&gt;
&lt;&lt;fib-machine&gt;&gt;
(set-register-contents! fib-machine 'n 6)
(fib-machine 'start)
(p (get-register-contents fib-machine 'val))
</pre></div>

<span id="index-5_002e13"></span>
<span id="Exercise-513"></span><p><strong>Exercise 5.13:</strong> Modify the simulator so that it uses the controller sequence to determine what registers the machine has rather than requiring a list of registers as an argument to make-machine. Instead of pre-allocating the registers in make-machine, you can allocate them one at a time when they are first seen during assembly of the instructions.
</p>
<p><strong>Solution</strong>
</p>
<hr>
<span id="Monitoring-Machine-Performance"></span><div class="header">
<p>
Previous: <a href="#Generating-Execution-Procedures-for-Instructions" accesskey="p" rel="prev">Generating Execution Procedures for Instructions</a>, Up: <a href="#A-Register_002dMachine-Simulator" accesskey="u" rel="up">A Register-Machine Simulator</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Monitoring-Machine-Performance-1"></span><h4 class="subsection">3.2.4 Monitoring Machine Performance</h4>

<hr>
<span id="Foreward"></span><div class="header">
<p>
Next: <a href="#Common-code" accesskey="n" rel="next">Common code</a>, Previous: <a href="#Computing-with-Register-Machines" accesskey="p" rel="prev">Computing with Register Machines</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Foreward-1"></span><h2 class="appendix">Appendix A Foreward</h2>

<ul>
<li> How the program behaves in society?

<p>Educators, generals, dieticians, psychologists, and parents program. Armies, students, and some societies are programmed.
</p>
</li><li> What does matter in program?

<p>It doesn’t matter much what the programs are about or what applications they serve. What does matter is how well they perform and how smoothly they fit with other programs in the creation of still greater programs.
</p>
<ul>
<li> Why?

<p>An assault on large problems employs a succession of programs, most of which spring into existence en route. These programs are rife with issues that appear to be particular to the problem at hand.
</p></li></ul>

</li><li> What are the three foci of phenomena with which our traffic with the subject matter of this book involves us?

<p>The human mind, collections of computer programs, and the computer.
</p>
</li><li> Why does program continually evolve?

<p>Every computer program is a model, hatched in the mind, of a real or mental process. These processes, arising from human experience and thought, are huge in number, intricate in detail, and at any time only partially understood. They are modeled to our permanent satisfaction rarely by our computer programs. Thus even though our programs are carefully handcrafted discrete collections of symbols, mosaics of interlocking functions, they continually evolve: we change them as our perception of the model deepens, enlarges, generalizes until the model ultimately attains a metastable place within still another model with which we struggle.
</p>
</li><li> What is the role of the organizational technique?

<p>Understanding these techniques is essential to participation in the Promethean enterprise called programming. More than anything else, the uncovering and mastery of powerful organizational techniques accelerates our ability to create large, significant programs.
</p>
<ul>
<li> Why?

<p>Computer programs must be correct, and what we wish to say must be said accurately in every detail. As in every other symbolic activity, we become convinced of program truth through argument. Lisp itself can be assigned a semantics (another model, by the way), and if a program’s function can be specified, say, in the predicate calculus, the proof methods of logic can be used to make an acceptable correctness argument. Unfortunately, as programs get large and complicated, as they almost always do, the adequacy, consistency, and correctness of the specifications themselves become open to doubt, so that complete formal arguments of correctness seldom accompany large programs. Since large programs grow from small ones, it is crucial that we develop an arsenal of standard program structures of whose correctness we have become sure—we call them idioms—and learn to combine them into larger structures using organizational techniques of proven value.
</p></li></ul>

</li><li> What&rsquo;s the relationship between hardware and program?

<p>In any event, hardware always operates at a level more primitive than that at which we care to program. The processes that transform our Lisp programs to “machine” programs are themselves abstract models which we program. Their study and creation give a great deal of insight into the organizational programs associated with programming arbitrary models.
</p>
</li><li> What are the consequences of breakthrough in hardware technology?

<p>The computers are never large enough or fast enough. Each breakthrough in hardware technology leads to more massive programming enterprises, new organizational principles, and an enrichment of abstract models.
</p>
</li><li> What does the algorithm care about?

<p>Execution time and data storage requirements.
</p>
</li><li> What are the characteristics of the list in Lisp?

<p>The simple structure and natural applicability of lists are reflected in functions that are amazingly nonidiosyncratic.
</p>
</li><li> What is the role of parsing technology in Lisp programs?

<p>In any very large programming task a useful organizing principle is to control and isolate traffic within the task modules via the invention of language. These languages tend to become less primitive as one approaches the boundaries of the system where we humans interact most often. As a result, such systems contain complex language-processing functions replicated many times. Lisp has such a simple syntax and semantics that parsing can be treated as an elementary task. Thus parsing technology plays almost no role in Lisp programs, and the construction of language processors is rarely an impediment to the rate of growth and change of large Lisp systems. Finally, it is this very simplicity of syntax and semantics that is responsible for the burden and freedom borne by all Lisp programmers. No Lisp program of any size beyond a few lines can be written without being saturated with discretionary functions. Invent and fit; have fits and reinvent!
</p>
</li><li> What concerns does the design of this introductory computer-science subject reflect?

<p>First, we want to establish the idea that a computer language is not just a way of getting a computer to perform operations but rather that it is a novel formal medium for expressing ideas about methodology. Thus, programs must be written for people to read, and only incidentally for machines to execute. Second, we believe that the essential material to be addressed by a subject at this level is not the syntax of particular programming-language constructs, nor clever algorithms for computing particular functions efficiently, nor even the mathematical analysis of algorithms and the foundations of computing, but rather the techniques used to control the intellectual complexity of large software systems.
</p>
</li><li> What is the goal of this subject?

<p>Our goal is that students who complete this subject should have a good feel for the elements of style and the aesthetics of programming. They should have command of the major techniques for controlling complexity in a large system. They should be capable of reading a 50-page-long program, if it is written in an exemplary style. They should know what not to read, and what they need not understand at any moment. They should feel secure about modifying a program, retaining the spirit and style of the original author.
</p>
</li><li> What are the ways to control complexity?

<p>These skills are by no means unique to computer programming. The techniques we teach and draw upon are common to all of engineering design. We control complexity by building abstractions that hide details when appropriate. We control complexity by establishing conventional interfaces that enable us to construct systems by combining standard, well-understood pieces in a “mix and match” way. We control complexity by establishing new languages for describing a design, each of which emphasizes particular aspects of the design and deemphasizes others.
</p>
</li><li> What is the conviction underlying our approach to this subject?

<p>“Computer science” is not a science and that its significance has little to do with computers. <strong>The computer revolution is a revolution in the way we think and in the way we express what we think.</strong> The essence of this change is the emergence of what might best be called procedural epistemology—the study of the structure of knowledge from an imperative point of view, as opposed to the more declarative point of view taken by classical mathematical subjects. Mathematics provides a framework for dealing precisely with notions of “what is.” <strong>Computation provides a framework for dealing precisely with notions of “how to.”</strong>
</p></li></ul>

<hr>
<span id="Common-code"></span><div class="header">
<p>
Next: <a href="#Main-Index" accesskey="n" rel="next">Main Index</a>, Previous: <a href="#Foreward" accesskey="p" rel="prev">Foreward</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Common-code-1"></span><h2 class="appendix">Appendix B Common code</h2>

<div class="example">
<pre class="example">(define true #t)
(define false #f)
(define nil '())
(define (p x) (newline) (display x) x)
(define (average x y) (/ (+ x y) 2))
(define (square x) (* x x))
(define (cube x) (* x x x))
(define (identity x) x)
(define (add-one x) (+ x 1))
(define (sub-one x) (- x 1))
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
(define (assoc key records)
  (cond ((null? records) false)
        ((equal? key (caar records))
         (car records))
        (else (assoc key (cdr records)))))
</pre></div>

<div class="example">
<pre class="example">#lang sicp
(#%require sicp-pict)
</pre></div>

<div class="example">
<pre class="example">&lt;&lt;common&gt;&gt;
&lt;&lt;sum&gt;&gt;
&lt;&lt;definite-integral&gt;&gt;
(define (r x)
  (let ((a 3)
        (b 0.26)
        (c -0.008))
    (+ a (* b x) (* c (square x)))))

(define (area x)
  (* 3.14159 (square (r x))))

(p (integral area 0 10 0.001))
</pre></div>

<hr>
<span id="Main-Index"></span><div class="header">
<p>
Next: <a href="#Procedure-Index" accesskey="n" rel="next">Procedure Index</a>, Previous: <a href="#Common-code" accesskey="p" rel="prev">Common code</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Main-Index-1"></span><h2 class="chapter">C Main Index</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Main-Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-cp" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-A">A</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-abstraction-barriers">abstraction barriers</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Building-Abstractions-with-Data">Building Abstractions with Data</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-applicative-order_002c-normal-order">applicative order, normal order</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Substitution-Model-for-Procedure-Application">The Substitution Model for Procedure Application</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-average-damping">average damping</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-General-Methods">Procedures as General Methods</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-C">C</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-closure-property">closure property</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hierarchical-Data-and-the-Closure-Property">Hierarchical Data and the Closure Property</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-combination">combination</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Expressions">Expressions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-computational-process">computational process</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Building-Abstractions-with-Procedures">Building Abstractions with Procedures</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-D">D</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-data">data</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Building-Abstractions-with-Procedures">Building Abstractions with Procedures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-data-abstraction">data abstraction</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Introduction-to-Data-Abstraction">Introduction to Data Abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-definite-integral">definite integral</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Arguments">Procedures as Arguments</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dynamic-scope">dynamic scope</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Black_002dBox-Abstractions">Procedures as Black-Box Abstractions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-E">E</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-environment">environment</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Naming-and-the-Environment">Naming and the Environment</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Euclid_2019s-Algorithm-for-computing-GCD">Euclid’s Algorithm for computing GCD</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Greatest-Common-Divisors">Greatest Common Divisors</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-evaluate-a-combination">evaluate a combination</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Evaluating-Combinations">Evaluating Combinations</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-F">F</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-Fermat_2019s-Little-Theorem">Fermat’s Little Theorem</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Testing-for-Primality">Example Testing for Primality</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-first_002dclass">first-class</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Returned-Values">Procedures as Returned Values</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fixed-point">fixed point</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-General-Methods">Procedures as General Methods</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-H">H</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-half-interval-method">half interval method</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-General-Methods">Procedures as General Methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-higher_002dorder-procedures">higher-order procedures</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formulating-Abstractions-with-Higher_002dOrder-Procedures">Formulating Abstractions with Higher-Order Procedures</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-I">I</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-interpreter">interpreter</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Building-Abstractions-with-Procedures">Building Abstractions with Procedures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-invariant-quantity">invariant quantity</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exponentiation">Exponentiation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-iterative-process">iterative process</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Linear-Recursion-and-Iteration">Linear Recursion and Iteration</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-L">L</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-lexical-scoping">lexical scoping</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Black_002dBox-Abstractions">Procedures as Black-Box Abstractions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-logarithmic-fibonacci-_0028linear-transformation_0029">logarithmic fibonacci (linear transformation)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exponentiation">Exponentiation</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-M">M</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-message-passing">message passing</a>:</td><td>&nbsp;</td><td valign="top"><a href="#What-Is-Meant-by-Data_003f">What Is Meant by Data?</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-O">O</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-order-of-growth">order of growth</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Orders-of-Growth">Orders of Growth</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-P">P</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-pair">pair</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Arithmetic-Operations-for-Rational-Numbers">Example Arithmetic Operations for Rational Numbers</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prefix-notation">prefix notation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Expressions">Expressions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prime">prime</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Testing-for-Primality">Example Testing for Primality</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prime-1">prime</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Testing-for-Primality">Example Testing for Primality</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-procedure">procedure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Compound-Procedures">Compound Procedures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-procedures">procedures</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Formulating-Abstractions-with-Higher_002dOrder-Procedures">Formulating Abstractions with Higher-Order Procedures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-program">program</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Building-Abstractions-with-Procedures">Building Abstractions with Procedures</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-R">R</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursive-process">recursive process</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Linear-Recursion-and-Iteration">Linear Recursion and Iteration</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-S">S</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-selectors-and-constructors">selectors and constructors</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Introduction-to-Data-Abstraction">Introduction to Data Abstraction</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-special-form">special form</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Evaluating-Combinations">Evaluating Combinations</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Main-Index_cp_letter-T">T</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-tail-recursive">tail recursive</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Linear-Recursion-and-Iteration">Linear Recursion and Iteration</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Main-Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Main-Index_cp_letter-T"><b>T</b></a>
 &nbsp; 
</td></tr></table>

<hr>
<span id="Procedure-Index"></span><div class="header">
<p>
Next: <a href="#Exercise-Index" accesskey="n" rel="next">Exercise Index</a>, Previous: <a href="#Main-Index" accesskey="p" rel="prev">Main Index</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Procedure-Index-1"></span><h2 class="chapter">D Procedure Index</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Procedure-Index_fn_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Procedure-Index_fn_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Procedure-Index_fn_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Procedure-Index_fn_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Procedure-Index_fn_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Procedure-Index_fn_letter-S"><b>S</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-fn" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Procedure-Index_fn_letter-A">A</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-accumulate_002dn"><code>accumulate-n</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Procedure-Index_fn_letter-F">F</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-fixed_002dpoint"><code>fixed-point</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-General-Methods">Procedures as General Methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fixed_002dpoint_002dof_002dtransform"><code>fixed-point-of-transform</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Returned-Values">Procedures as Returned Values</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-flatmap"><code>flatmap</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fold_002dleft"><code>fold-left</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fringe-tree"><code>fringe tree</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hierarchical-Structures">Hierarchical Structures</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Procedure-Index_fn_letter-H">H</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-half_002dinterval_002dmethod"><code>half-interval-method</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-General-Methods">Procedures as General Methods</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Procedure-Index_fn_letter-M">M</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-miller-rabin-test-prime"><code>miller rabin test prime</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Testing-for-Primality">Example Testing for Primality</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Procedure-Index_fn_letter-P">P</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-permutations"><code>permutations</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Procedure-Index_fn_letter-S">S</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-scale_002dtree"><code>scale-tree</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hierarchical-Structures">Hierarchical Structures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-subsets"><code>subsets</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hierarchical-Structures">Hierarchical Structures</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Procedure-Index_fn_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Procedure-Index_fn_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Procedure-Index_fn_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Procedure-Index_fn_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Procedure-Index_fn_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Procedure-Index_fn_letter-S"><b>S</b></a>
 &nbsp; 
</td></tr></table>

<hr>
<span id="Exercise-Index"></span><div class="header">
<p>
Previous: <a href="#Procedure-Index" accesskey="p" rel="prev">Procedure Index</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Main-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Exercise-Index-1"></span><h2 class="chapter">E Exercise Index</h2>

<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Exercise-Index_pg_symbol-1"><b>1</b></a>
 &nbsp; 
<a class="summary-letter" href="#Exercise-Index_pg_symbol-2"><b>2</b></a>
 &nbsp; 
<a class="summary-letter" href="#Exercise-Index_pg_symbol-3"><b>5</b></a>
</td></tr></table>
<table class="index-pg" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Exercise-Index_pg_symbol-1">1</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e01"><code>1.01</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conditional-Expressions-and-Predicates">Conditional Expressions and Predicates</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e02"><code>1.02</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conditional-Expressions-and-Predicates">Conditional Expressions and Predicates</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e03"><code>1.03</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conditional-Expressions-and-Predicates">Conditional Expressions and Predicates</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e04"><code>1.04</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conditional-Expressions-and-Predicates">Conditional Expressions and Predicates</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e05"><code>1.05</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Conditional-Expressions-and-Predicates">Conditional Expressions and Predicates</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e06"><code>1.06</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Square-Roots-by-Newton_0027s-Method">Example Square Roots by Newton's Method</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e07"><code>1.07</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Square-Roots-by-Newton_0027s-Method">Example Square Roots by Newton's Method</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e08"><code>1.08</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Square-Roots-by-Newton_0027s-Method">Example Square Roots by Newton's Method</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e09"><code>1.09</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Linear-Recursion-and-Iteration">Linear Recursion and Iteration</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e10"><code>1.10</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Linear-Recursion-and-Iteration">Linear Recursion and Iteration</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e11"><code>1.11</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tree-Recursion">Tree Recursion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e12"><code>1.12</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tree-Recursion">Tree Recursion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e13"><code>1.13</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tree-Recursion">Tree Recursion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e14"><code>1.14</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Orders-of-Growth">Orders of Growth</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e15"><code>1.15</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Orders-of-Growth">Orders of Growth</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e16"><code>1.16</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exponentiation">Exponentiation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e17"><code>1.17</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exponentiation">Exponentiation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e18"><code>1.18</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exponentiation">Exponentiation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e19"><code>1.19</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exponentiation">Exponentiation</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e20"><code>1.20</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Greatest-Common-Divisors">Greatest Common Divisors</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e21"><code>1.21</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Testing-for-Primality">Example Testing for Primality</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e22"><code>1.22</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Testing-for-Primality">Example Testing for Primality</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e23"><code>1.23</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Testing-for-Primality">Example Testing for Primality</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e24"><code>1.24</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Testing-for-Primality">Example Testing for Primality</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e25"><code>1.25</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Testing-for-Primality">Example Testing for Primality</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e26"><code>1.26</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Testing-for-Primality">Example Testing for Primality</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e27"><code>1.27</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Testing-for-Primality">Example Testing for Primality</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e28-variant-of-the-Fermat-test"><code>1.28 variant of the Fermat test</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Testing-for-Primality">Example Testing for Primality</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e29-Simpson_2019s-Rule-of-integration"><code>1.29 Simpson’s Rule of integration</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Arguments">Procedures as Arguments</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e30-iterative-sum"><code>1.30 iterative sum</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Arguments">Procedures as Arguments</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e31-product-pi"><code>1.31 product pi</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Arguments">Procedures as Arguments</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e32-accumulate"><code>1.32 accumulate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Arguments">Procedures as Arguments</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e33-filtered_002daccumulate"><code>1.33 filtered-accumulate</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Arguments">Procedures as Arguments</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e34"><code>1.34</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Constructing-Procedures-Using-Lambda">Constructing Procedures Using Lambda</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e35-golden-ratio"><code>1.35 golden ratio</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-General-Methods">Procedures as General Methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e36-with_002fwithout-average-damping"><code>1.36 with/without average damping</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-General-Methods">Procedures as General Methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e37-continued-fraction"><code>1.37 continued fraction</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-General-Methods">Procedures as General Methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e38-continued-fraction_002c-Euler_0027s-number"><code>1.38 continued fraction, Euler's number</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-General-Methods">Procedures as General Methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e39-continued-fraction_002c-tangent"><code>1.39 continued fraction, tangent</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-General-Methods">Procedures as General Methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e40"><code>1.40</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Returned-Values">Procedures as Returned Values</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e41"><code>1.41</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Returned-Values">Procedures as Returned Values</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e42"><code>1.42</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Returned-Values">Procedures as Returned Values</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e43"><code>1.43</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Returned-Values">Procedures as Returned Values</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e44-smoothed-function"><code>1.44 smoothed function</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Returned-Values">Procedures as Returned Values</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e45-nth-root"><code>1.45 nth root</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Returned-Values">Procedures as Returned Values</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-1_002e46-iterative-improvement"><code>1.46 iterative improvement</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Procedures-as-Returned-Values">Procedures as Returned Values</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Exercise-Index_pg_symbol-2">2</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e01-negative-rational"><code>2.01 negative rational</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-Arithmetic-Operations-for-Rational-Numbers">Example Arithmetic Operations for Rational Numbers</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e02-segment-point"><code>2.02 segment point</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstraction-Barriers">Abstraction Barriers</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e03-rectangle"><code>2.03 rectangle</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstraction-Barriers">Abstraction Barriers</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e04-procedural-representation-of-pairs"><code>2.04 procedural representation of pairs</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#What-Is-Meant-by-Data_003f">What Is Meant by Data?</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e05-numbers-represent-pairs"><code>2.05 numbers represent pairs</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#What-Is-Meant-by-Data_003f">What Is Meant by Data?</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e06-Church-numerals"><code>2.06 Church numerals</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#What-Is-Meant-by-Data_003f">What Is Meant by Data?</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e07-selectors"><code>2.07 selectors</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Extended-Exercise-Interval-Arithmetic">Extended Exercise Interval Arithmetic</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e08-sub"><code>2.08 sub</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Extended-Exercise-Interval-Arithmetic">Extended Exercise Interval Arithmetic</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e09-width"><code>2.09 width</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Extended-Exercise-Interval-Arithmetic">Extended Exercise Interval Arithmetic</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e10-div-denominator-check"><code>2.10 div denominator check</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Extended-Exercise-Interval-Arithmetic">Extended Exercise Interval Arithmetic</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e11-center-width"><code>2.11 center width</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Extended-Exercise-Interval-Arithmetic">Extended Exercise Interval Arithmetic</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e12-center-percent"><code>2.12 center percent</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Extended-Exercise-Interval-Arithmetic">Extended Exercise Interval Arithmetic</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e13"><code>2.13</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Extended-Exercise-Interval-Arithmetic">Extended Exercise Interval Arithmetic</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e14"><code>2.14</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Extended-Exercise-Interval-Arithmetic">Extended Exercise Interval Arithmetic</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e15"><code>2.15</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Extended-Exercise-Interval-Arithmetic">Extended Exercise Interval Arithmetic</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e16"><code>2.16</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Extended-Exercise-Interval-Arithmetic">Extended Exercise Interval Arithmetic</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e17-last_002dpair"><code>2.17 last-pair</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Representing-Sequences">Representing Sequences</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e18-reverse"><code>2.18 reverse</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Representing-Sequences">Representing Sequences</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e19-change_002dcounting"><code>2.19 change-counting</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Representing-Sequences">Representing Sequences</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e20-arbitrary-numbers-of-arguments"><code>2.20 arbitrary numbers of arguments</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Representing-Sequences">Representing Sequences</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e21-square_002dlist"><code>2.21 square-list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Representing-Sequences">Representing Sequences</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e22-cons-order"><code>2.22 cons order</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Representing-Sequences">Representing Sequences</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e23-for_002deach"><code>2.23 for-each</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Representing-Sequences">Representing Sequences</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e24-structure"><code>2.24 structure</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hierarchical-Structures">Hierarchical Structures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e25-access-list-element"><code>2.25 access list element</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hierarchical-Structures">Hierarchical Structures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e26-combine-list"><code>2.26 combine list</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hierarchical-Structures">Hierarchical Structures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e27-deep_002dreverse"><code>2.27 deep-reverse</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hierarchical-Structures">Hierarchical Structures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e28-fringe-tree"><code>2.28 fringe tree</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hierarchical-Structures">Hierarchical Structures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e29"><code>2.29</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hierarchical-Structures">Hierarchical Structures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e30-square_002dtree"><code>2.30 square-tree</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hierarchical-Structures">Hierarchical Structures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e31-tree_002dmap"><code>2.31 tree-map</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hierarchical-Structures">Hierarchical Structures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e32-generate-the-set-of-subsets-of-a-set"><code>2.32 generate the set of subsets of a set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hierarchical-Structures">Hierarchical Structures</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e33-list_002dmanipulation-operations-as-accumulations"><code>2.33 list-manipulation operations as accumulations</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e34-Horner_2019s-rule"><code>2.34 Horner’s rule</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e35-count_002dleaves-with-accumulation"><code>2.35 count-leaves with accumulation</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e36-accumulate_002dn"><code>2.36 accumulate-n</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e37-matrix"><code>2.37 matrix</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e38-fold_002dright-fold_002dleft"><code>2.38 fold-right fold-left</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e39"><code>2.39</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e40-improve-prime_002dsum_002dpairs"><code>2.40 improve prime-sum-pairs</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e41-triple-loops"><code>2.41 triple loops</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e42-eight_002dqueens-puzzle"><code>2.42 eight-queens puzzle</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e43"><code>2.43</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequences-as-Conventional-Interfaces">Sequences as Conventional Interfaces</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e44-up_002dsplit"><code>2.44 up-split</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-A-Picture-Language">Example A Picture Language</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e45-general-split"><code>2.45 general split</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-A-Picture-Language">Example A Picture Language</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e46-vect-constructor-and-selector"><code>2.46 vect constructor and selector</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-A-Picture-Language">Example A Picture Language</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-2_002e47-frame-constructor-and-selector"><code>2.47 frame constructor and selector</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Example-A-Picture-Language">Example A Picture Language</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Exercise-Index_pg_symbol-3">5</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-5_002e01"><code>5.01</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Designing-Register-Machines">Designing Register Machines</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-5_002e02"><code>5.02</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#A-Language-for-Describing-Register-Machines">A Language for Describing Register Machines</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-5_002e03"><code>5.03</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Abstraction-in-Machine-Design">Abstraction in Machine Design</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-5_002e04"><code>5.04</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Using-a-Stack-to-Implement-Recursion">Using a Stack to Implement Recursion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-5_002e05"><code>5.05</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Using-a-Stack-to-Implement-Recursion">Using a Stack to Implement Recursion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-5_002e06"><code>5.06</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Using-a-Stack-to-Implement-Recursion">Using a Stack to Implement Recursion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-5_002e07"><code>5.07</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#A-Register_002dMachine-Simulator">A Register-Machine Simulator</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-5_002e08"><code>5.08</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-Assembler">The Assembler</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-5_002e09"><code>5.09</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generating-Execution-Procedures-for-Instructions">Generating Execution Procedures for Instructions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-5_002e10"><code>5.10</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generating-Execution-Procedures-for-Instructions">Generating Execution Procedures for Instructions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-5_002e11"><code>5.11</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generating-Execution-Procedures-for-Instructions">Generating Execution Procedures for Instructions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-5_002e12"><code>5.12</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generating-Execution-Procedures-for-Instructions">Generating Execution Procedures for Instructions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-5_002e13"><code>5.13</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Generating-Execution-Procedures-for-Instructions">Generating Execution Procedures for Instructions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Exercise-Index_pg_symbol-1"><b>1</b></a>
 &nbsp; 
<a class="summary-letter" href="#Exercise-Index_pg_symbol-2"><b>2</b></a>
 &nbsp; 
<a class="summary-letter" href="#Exercise-Index_pg_symbol-3"><b>5</b></a>
</td></tr></table>

<hr>



</body>
</html>
